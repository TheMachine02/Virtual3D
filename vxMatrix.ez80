#define	VX_MATRIX_SIZE	18

vxIdentityMatrix:
.db	64,0,0
.db	0,64,0
.db	0,0,64
.dl	0,0,0

vxMatrixLoadIdentity:
; input : hl matrix
	ex	de, hl
	ld	hl, vxIdentityMatrix
	ld	bc, VX_MATRIX_SIZE
	ldir
	ex	de, hl
	ld	bc, -VX_MATRIX_SIZE
	add	hl, bc
	ret
vxMatrixRotationX:
#comment
	ld	a, l
	ld	hl, ISIN_TABLE
	ld	l, a
	ld	a, (hl)
	ld	(ix+7), a
	neg
	ld	(ix+5), a
	ld	a, l
	add	a, 64
	ld	l, a
	ld	c, (hl)
	ld	(ix+4), c
	ld	(ix+8), c
	ld	a, 64
	ld	(ix+0), a
	xor	a, a
	ld	(ix+1), a
	ld	(ix+2), a
	ld	(ix+3), a
	ld	(ix+6), a
#endcomment
	push	hl
	call	vxSin
	ld	a, h
	ld	(ix+7), a
	neg
	ld	(ix+5), a
	pop	hl
	call	vxCos
	ld	(ix+4), h
	ld	(ix+8), h
	ld	a, 64
	ld	(ix+0), a
	xor	a, a
	ld	(ix+1), a
	ld	(ix+2), a
	ld	(ix+3), a
	ld	(ix+6), a
	ret
vxMatrixRotationZ:
#comment
	ld	a, l
	ld	hl, ISIN_TABLE
	ld	l, a
	ld	a, (hl)
	ld	(ix+3), a
	neg
	ld	(ix+1), a
	ld	a, l
	add	a, 64
	ld	l, a
	ld	c, (hl)
	ld	(ix+0), c
	ld	(ix+4), c
	ld	a, 64
	ld	(ix+8), a
	xor	a, a
	ld	(ix+2), a
	ld	(ix+6), a
	ld	(ix+7), a
	ld	(ix+5), a
#endcomment
	push	hl
	call	vxSin
	ld	a, h
	ld	(ix+3), a
	neg
	ld	(ix+1), a
	pop	hl
	call	vxCos
	ld	(ix+0), h
	ld	(ix+4), h
	ld	a, 64
	ld	(ix+8), a
	xor	a, a
	ld	(ix+2), a
	ld	(ix+6), a
	ld	(ix+7), a
	ld	(ix+5), a
	ret
vxMatrixRotationY:
	push	hl
	call	vxSin
	ld	a, h
	ld	(ix+2), a
	neg
	ld	(ix+6), a
	pop	hl
	call	vxCos
	ld	(ix+0), h
	ld	(ix+8), h
	ld	a, 64
	ld	(ix+4), a
	xor	a, a
	ld	(ix+1), a
	ld	(ix+3), a
	ld	(ix+5), a
	ld	(ix+7), a
	ret
vxMatrixMlt:
; (hl) = (iy) * (ix)
; 116 bytes, ~3800 TStates
	ex	de, hl
	ld	bc, 768
vxMatrixColLoop:
	push	bc
	ld	b, 3
vxMatrixRowLoop:
	push	bc
	ld	h, (ix+0)
	ld	l, (iy+0)
	xor	a, a
	bit	7, h \ jr z, $+3 \ sub a, l
	bit	7, l \ jr z, $+3 \ sub a, h
	mlt	hl
	ld	b, (ix+1)
	ld	c, (iy+3)
	bit	7, b \ jr z, $+3 \ sub a, c
	bit	7, c \ jr z, $+3 \ sub a, b
	mlt	bc
	add	hl, bc
	ld	b, (ix+2)
	ld	c, (iy+6)
	bit	7, b \ jr z, $+3 \ sub a, c
	bit	7, c \ jr z, $+3 \ sub a, b
	mlt	bc
	add	hl, bc
	ld	b, a
	xor	a, a
	ld	c, a
	add	hl, bc
	add	hl, hl
	add	hl, hl
	ld	a, h
	ld	(de), a
	inc	de
	inc	iy
	pop	bc
	djnz	vxMatrixRowLoop
	lea	ix, ix+3
	lea	iy, iy-3
	pop	bc
	djnz	vxMatrixColLoop
	lea	ix, ix-9
	ex	de, hl
	ld	bc, -9
	add	hl, bc
	ret
vxMatrixTransform:
; (hl) = (iy)*(ix) with translation
; iy is a animation matrix, ix is a world matrix, hl is world matrix
	push	hl
	lea	iy, iy+9	; load up the translation of matrix 0
	call	vxfTransform
	lea	iy, iy-9
	pop	hl
	call	vxMatrixMlt
; copy translation data to result (hl)
	ld	bc, 9
	add	hl, bc
	ld	de, vxPosition
	ex	de, hl
	ldir
	ld	bc, -VX_MATRIX_SIZE
	ex	de, hl
	add	hl, bc
	ret
vxMatrixTranspose:
; 192 TStates + translation
	ld	c, (ix+3)
	ld	a, (ix+1)
	ld	(ix+3), a
	ld	(ix+1), c
	ld	c, (ix+6)
	ld	a, (ix+2)
	ld	(ix+6), a
	ld	(ix+2), c
	ld	c, (ix+7)
	ld	a, (ix+5)
	ld	(ix+7), a
	ld	(ix+5), c	
#comment
	ld	de, (ix+9)
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ix+9), hl
	ld	de, (ix+12)
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ix+12), hl
	ld	de, (ix+15)
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ix+15), hl
#endcomment
	ret
vxMatrixLightning:
	ex	de, hl
	ld	b, 3
vxMatrixLightLoop:
	push	bc
	push	de
	call	vxDotProduct
	pop	de
	add	hl, hl
	add	hl, hl
	ld	a, h
	ld	(de), a
	inc	de
	lea	ix, ix+3
	pop	bc
	djnz	vxMatrixLightLoop
	lea	ix, ix-9
	push	de
	ld	hl, (iy+VX_LIGHT_POSITION)
	ld	de, (iy+VX_LIGHT_POSITION+3)
	or	a, a
	sbc	hl, de
	pop	hl
	jr	z, vxMatrixLightEarlyOut
	dec	hl \ dec hl \ dec hl
	push	hl
; transform lightning position
	call	vxfTransform
; fetch value and divide them
; value should be copied to (hl)	
	pop	hl
	ld	bc, VX_LIGHT_POSITION+3
	add	hl, bc
	ex	de, hl
; de = adress of position.
	ld	hl, (vxPosition+6)
	add	hl, hl
	add	hl, hl
; copy hlu, h to (de)
	ex	de, hl
	ld	(hl), de
	dec	hl
	dec	hl	
	ex	de, hl
	ld	hl, (vxPosition+3)
	add	hl, hl
	add	hl, hl
	ex	de, hl
	ld	(hl), de
	dec	hl
	dec	hl
	ex	de, hl
	ld	hl, (vxPosition)
	add	hl, hl
	add	hl, hl
	ex	de, hl
	ld	(hl), de
; AMBIANT_VALUE was writed with bad value.
vxMatrixLightEarlyOut:
	ld	a, (iy+VX_LIGHT_AMBIANT)
	ld	(hl), a
	dec	hl \ dec hl \ dec hl
	ret
vxfTransform:
; input : iy vector, ix matrix
; [ix+0]*[iy]+[ix+1]*[iy+2]+[ix+2]*[iy+4]+[ix+9]=x
; [ix+3]*[iy]+[ix+4]*[iy+2]+{ix+5]*[iy+4]+[ix+12]=y
; [ix+6]*[iy]+[ix+7]*[iy+2]+[ix+8]*[iy+4]+[ix+15]=z
; From 1566+x? TStates to 1654 TStates, 333 bytes
; X coordinate
	ld	bc, (iy+0)
	ld	hl, (ix+9)
	ld	a, (ix+0)
	madd
	ld	a, (ix+1)
	ld	bc, (iy+2)
	madd
	ld	a, (ix+2)
	ld	bc, (iy+4)
	madd.f
	ld	(vxPosition), hl
; Y coordinate
	ld	hl, (ix+12)
	ld	a, (ix+5)
	madd
	ld	a, (ix+4)
	ld	bc, (iy+2)
	madd
	ld	a, (ix+3)
	ld	bc, (iy+0)
	madd.f
	ld	(vxPosition+3), hl
; Z coordinate
	ld	hl, (ix+15)
	ld	a, (ix+6)
	madd
	ld	a, (ix+7)
	ld	bc, (iy+2)
	madd
	ld	a, (ix+8)
	ld	bc, (iy+4)
	madd
	ld	(vxPosition+6), hl
	ret
