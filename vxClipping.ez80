#define  vxPlaneBit0             %10000000
#define  vxPlaneBit1             %01000000
#define  vxPlaneBit2             %00100000
#define  vxPlaneBit3             %00010000
#define  vxPlaneBit4             %00001000
#define  vxVertexDirty           %11111111
;;#define  VX_CLIP_EPSILON        	32
#define  VX_MAX_TMP_VERTEX       8
#define  VX_MAX_PATCH_SIZE       16
#define  VX_SCREEN_WIDTH         320
#define  VX_SCREEN_HEIGHT        240
#define  VX_SCREEN_WCENTER       160
#define  VX_SCREEN_HCENTER       120

VX_PATCH_INPUT:
	.fill	64
VX_PATCH_OUTPUT:
	.fill	64
VX_VERTEX_POOL:
	.fill	128
vxNewSize:
	.db	0
vxVertexAdress:
	.dl	0
VX_CLIP_VERTEX0:
	.dl	0,0,0,0,0,0
VX_CLIP_VERTEX1:
	.dl	0,0,0,0,0,0
vxMixWrite:
	.db	0,0,0,0

vxClipTriangle:
	ld	(vxClipDraw), iy
	ld	iy, VX_PATCH_OUTPUT
	ld	(iy+0), de
	ld	(iy+3), hl
	ld	(iy+6), bc
	ld	(iy+9), de
	ld	hl, VX_VERTEX_POOL
	ld	(vxVertexAdress), hl

	ld	b, 3

	tst	a, %10000000
	jr	z, vxNextPlane0
	push	af
	ld	a, %10000000
	ld	ix, vxRightDistance
	call	vxClipPlanePolygon
	pop	af
vxNextPlane0:
	tst	a, %01000000
	jr	z, vxNextPlane1
	push	af
	ld	a, %01000000
	ld	ix, vxLeftDistance
	call	vxClipPlanePolygon
	pop	af
vxNextPlane1:
	tst	a, %00100000
	jr	z, vxNextPlane2
	push	af
	ld	a, %00100000
	ld	ix, vxDownDistance
	call	vxClipPlanePolygon
	pop	af
vxNextPlane2:
	tst	a, %00010000
	jr	z, vxClipEnd
	push	af
	ld	a, %00010000
	ld	ix, vxUpDistance
	call	vxClipPlanePolygon
	pop	af
vxClipEnd:

	ld	a, b
	cp	a, 3
	ret	c	; preventive quit
	push	af
	push	iy
	lea	ix, iy+0
vxClipLoop:
	push	bc
	ld	iy, (ix+0)
	ld	a, (iy+0)
	and	$01
	call	nz, vxClipDivide
	pop	bc
	lea	ix, ix+3
	djnz	vxClipLoop
	pop	iy
	pop	af
vxClipDraw=$+1
	jp	$000000
vxClipDistance:
CALL=$+1
	jp	$000000
vxClipPlanePolygon:
; don't destroy bc
; input : iy list, b:size,ix:dcall, a:mask
; ouput : iy newlist, b:newsize
	ld	(vxMM0), a
	ld	(vxMM1), a
	ld	(vxMM2), a
	xor	a
	ld	(vxNewSize), a
	ld	a, b
	or	a, a
	ret	z
	ld	(CALL), ix

	inc	b
	ld	c, 3
	mlt	bc	; size of copy
	lea	hl, iy
	ld	de, VX_PATCH_INPUT
	ldir
; parse through VX_PATCH_INPUT, output is VX_PATCH_OUTPUT
	ld	b, a
	ld	iy, VX_PATCH_INPUT
	ld	ix, VX_PATCH_OUTPUT
vxClipSutherHodgmanLoop:
	push	bc
	ld	hl, (iy+0)
	ld	de, (iy+3)
	ld	a, (de)
	and	(hl)
vxMM0=$+1
	and	0
	jp	nz, vxClipContinueX
	ld	a, (de)
	or	(hl)
vxMM1=$+1
	and	0
	jr	nz, vxClipCheck0
	ld	(ix+0), hl		; both point out, copy v0
	lea	ix, ix+3
	ld	a, (vxNewSize)
	inc	a
	ld	(vxNewSize), a
	jp	vxClipContinueX
vxClipCheck0:
	ld	a, (hl)
	push	ix
	call	vxClipDistance
	ex	de, hl	; distance 0
	call	vxClipDistance
vxMM2=$+1
	and	0
	push	af	; is edge leaving

	push	hl
	or	a, a
	sbc	hl, de	; d0/(d0-d1)
	pop	de
	ex	de, hl
	call	vxClipFactor

	ld	ix, (iy+3)
	ld	de, (ix+VX_VERTEX_RZ)
	ld	ix, (iy+0)
	ld	hl, (ix+VX_VERTEX_RZ)
	call	vxClipMixWord
	ld	(VX_CLIP_VERTEX0+VX_VERTEX_RZ), hl

	ld	ix, (iy+3)
	ld	de, (ix+VX_VERTEX_RX)
	ld	ix, (iy+0)
	ld	hl, (ix+VX_VERTEX_RX)
	call	vxClipMixWord
	ld	(VX_CLIP_VERTEX0+VX_VERTEX_RX), hl

	ld	ix, (iy+3)
	ld	de, (ix+VX_VERTEX_RY)
	ld	ix, (iy+0)
	ld	hl, (ix+VX_VERTEX_RY)
	call	vxClipMixWord
	ld	(VX_CLIP_VERTEX0+VX_VERTEX_RY), hl

	ld	de, 0
	ld	ix, (iy+3)
	ld	e, (ix+VX_VERTEX_GPR0)
	ld	ix, (iy+0)
	ld	d, (ix+VX_VERTEX_GPR0)
	;;call	vxClipMixByte
	ld	a, d
	sub	e
	ld	l, a
	ld	h, b
	mlt	hl
	jr	nc, $+5
	ld	a, h
	sub	b
	ld	h, a
	ld	d, e
	ld	e, 0
	add	hl, de
	ld	a, h

	ld	(VX_CLIP_VERTEX0+VX_VERTEX_GPR0), a

	ld	ix, (iy+3)
	ld	e, (ix+VX_VERTEX_GPR1)
	ld	ix, (iy+0)
	ld	d, (ix+VX_VERTEX_GPR1)
	;call	vxClipMixByte

	ld	a, d
	sub	e
	ld	l, a
	ld	h, b
	mlt	hl
	jr	nc, $+5
	ld	a, h
	sub	b
	ld	h, a
	ld	d, e
	ld	e, 0
	add	hl, de
	ld	a, h

	ld	(VX_CLIP_VERTEX0+VX_VERTEX_GPR1), a

	ld	ix, VX_CLIP_VERTEX0+0
	call	vxClipFrustrumCode
	or	a, $01
	ld	(ix+0), a

; do specific edge shift here
	pop	af
	pop	ix

	jp	nz, vxEdgeRentring
; edge leaving
; copy clip vertex, output both v0 and intersection
	ld	hl, (iy+0)
	ld	(ix+0), hl
	ld	hl, VX_CLIP_VERTEX0
	ld	de, (vxVertexAdress)
	ld	(ix+3), de
	ld	bc, 16
	ldir
	ld	(vxVertexAdress), de
	lea	ix, ix+6
	ld	a, (vxNewSize)
	add	a, 2
	ld	(vxNewSize), a
	jr	vxClipContinueX
vxEdgeRentring:
; copy clip vertex, output intersection
	ld	hl, VX_CLIP_VERTEX0
	ld	de, (vxVertexAdress)
	ld	(ix+0), de
	ld	bc, 16
	ldir
	ld	(vxVertexAdress), de
	lea	ix, ix+3
	ld	a, (vxNewSize)
	inc	a
	ld	(vxNewSize), a
vxClipContinueX:
	lea	iy, iy+3
	pop	bc
	dec	b
	jp	nz, vxClipSutherHodgmanLoop
	ld	a, (vxNewSize)
	ld	b, a
	ld	iy, VX_PATCH_OUTPUT
; make output cyclic
	ld	hl, (iy+0)
	ld	(ix+0), hl
; important is iy = new patch
	ret
vxZDistance:
	ld	bc, VX_VERTEX_RZ
	add	hl, bc
	ld	hl, (hl)
	dec	hl
	ret
vxRightDistance:
tRT:
;1000
; input hl, test for X>Z
	ld	bc, VX_VERTEX_RX
	add	hl, bc
	ld	bc, (hl)
	inc	hl \ inc hl \ inc hl
	inc	hl \ inc hl \ inc hl
	ld	hl, (hl)
	or	a, a
	sbc	hl, bc	;Z-X, if > ; R<0
	ret
vxLeftDistance:
ttLT:
; 0100
	ld	bc, VX_VERTEX_RX
	add	hl, bc
	ld	bc, (hl)
	inc	hl \ inc hl \ inc hl
	inc	hl \ inc hl \ inc hl
	ld	hl, (hl)
	add	hl, bc
	ret
vxDownDistance:
tDWP:
	ld	bc, VX_VERTEX_RY
	add	hl, bc
	ld	bc, (hl)
	inc	hl \ inc hl \ inc hl
	ld	hl, (hl)
	or	a, a
	sbc	hl, bc
	ret
vxUpDistance:
tUPP:
	ld	bc, VX_VERTEX_RY
	add	hl, bc
	ld	bc, (hl)
	inc	hl \ inc hl \ inc hl
	ld	hl, (hl)
	add	hl, bc
	ret

vxClipMixByte:
; a = (d-e)*bc/65536+e
	ld	a, d
	sub	e
	ld	l, a
	ld	h, b
	mlt	hl
	jr	nc, $+5
	or	a, a
	sbc	hl, bc
	ld	d, e
	ld	e, 0
	add	hl, de
	ret

vxClipMixWord:
; (hl-de)*bc/65536+de
	push	de
	or	a, a
	sbc	hl, de
	ld	(vxMixWrite), hl
	ld	ix, vxMixWrite

	ld	h, (ix+2)
	bit	7, h
	ld	l, b
	mlt	hl
	jr	z, $+5
	or	a, a
	sbc	hl, bc

	slhl

	ld	d, (ix+1)
	ld	e, b
	mlt	de
	add	hl, de

	ld	d, (ix+0)
	ld	e, b
	mlt	de
	ld	e, d
	ld	d, 0
	add	hl, de

	ld	d, (ix+2)
	ld	e, c
	mlt	de
	add	hl, de

	ld	d, (ix+1)
	ld	e, c
	mlt	de
	ld	e, d
	ld	d, 0
	add	hl, de

	pop	de
	add	hl, de

	ret

vxClipFactor:
; hl*65536/de, nz = do 65536-bc, z = bc
; 467 TStates
   inc.s bc
   add   hl,hl
	jr	nc, vxx
	push	de
	ex	de, hl
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	pop	de

	push	hl
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ex	de, hl
	pop	hl

vxx:
	sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   cpl
   ld   b, a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ jr nc,$+3 \ add hl,de \ adc a,a
   add   hl,hl \ sbc hl,de \ adc a,a
   cpl
   ld   c, a
	ret

vxClipDivide:
	ld	bc, (iy+VX_VERTEX_RZ)
	bit	7, (iy+VX_VERTEX_RZ+2)
	jr	z, vxClampZ
	ld	bc, 2
vxClampZ:
	ld	hl, (iy+VX_VERTEX_RY)
	xor	a, a
	add	hl, hl
	jr	nc, $+8
	rla
	ex   de, hl
	sbc   hl, hl
	sbc   hl, de

	sbc	hl, bc \ jp m, vxClipNextY
	or	a, a
; potential clipping issue
	sbc	hl, bc
	jp	m, vxClipNextYCarry
	rra
	ld	a, VX_SCREEN_HCENTER-(VX_SCREEN_HEIGHT/2)
	jr	nc, vxClipWriteY
	ld	a, VX_SCREEN_HCENTER+(VX_SCREEN_HEIGHT/2)
	jr	vxClipWriteY
vxClipNextYCarry:
	or	a, a
vxClipNextY:
   adc a,a \ add hl,bc
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ adc a,a
   cpl

   add   a, a
   ld   l, VX_SCREEN_HEIGHT/2+1 ;precision stuffs
   ld   h, a
   mlt   hl
   ld   a, h
   jr   nc, $+3
   cpl
   adc   a, VX_SCREEN_HCENTER
vxClipWriteY:
	ld	(iy+VX_VERTEX_SY), a

	ld	hl, (iy+VX_VERTEX_RX)
	xor	a, a
	add	hl, hl
	jr	nc, $+8
	rla
	ex   de, hl
	sbc   hl, hl
	sbc   hl, de

	sbc	hl, bc \ jp m, vxClipNextX
	or	a, a
; potential clipping issue
	sbc	hl, bc
	jp	m, vxClipNextXCarry
	rra
	ld	hl, VX_SCREEN_WCENTER-(VX_SCREEN_WIDTH/2)
	jr	c, vxClipWriteX
	ld	hl, VX_SCREEN_WCENTER+(VX_SCREEN_WIDTH/2)
	jr	vxClipWriteX
vxClipNextXCarry:
	or	a, a
vxClipNextX:
   adc a,a \ add hl,bc
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
   add hl,hl \ sbc hl,bc \ adc a,a
   cpl
   ld   e, a
   ld   d, VX_SCREEN_WIDTH/2+1
   mlt   de
   ld    a, d
   sbc   hl, hl
   jr   nc, $+3
   cpl
   ld   l, a
   ld   de, VX_SCREEN_WCENTER
   adc   hl, de
vxClipWriteX:
	ld	(iy+VX_VERTEX_SX), l
	ld	(iy+VX_VERTEX_SX+1), h
	xor	a, a
	ld	(iy+VX_VERTEX_CODE), a
	ret

vxClipFrustrumCode:
	ld	hl, (ix+VX_VERTEX_RY)
	ld	de, (ix+VX_VERTEX_RX)
	ld	bc, (ix+VX_VERTEX_RZ)
	xor	a, a
	sbc	hl, bc
	jp	m, vxClipError0
	or	%00100000
vxClipError0:
	add	hl, bc
	or	a, a
	adc	hl, bc
	jp	p, vxClipError1
	or	%00010000
vxClipError1:
; y cliping was handled
	ex	de, hl
	sbc	hl, bc
	jp	m, vxClipError2
	or	a, %10000000
vxClipError2:
	add	hl, bc
	or	a, a
	adc	hl, bc
	jp	p, vxClipError3
	or	a, %01000000
vxClipError3:
; x clipping handled
	bit	7, (ix+VX_VERTEX_RZ+2)
	ret	z
	or	%00001000
	ret
