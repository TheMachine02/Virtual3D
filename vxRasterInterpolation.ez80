#define	VX_REGISTER_Y0	-32+0
#define	VX_REGISTER_X0	-32+1
#define	VX_REGISTER_U0	-32+3
#define	VX_REGISTER_V0	-32+4
#define	VX_REGISTER_C0	-32+5
#define	VX_REGISTER_Y1	-26+0
#define	VX_REGISTER_X1	-26+1
#define	VX_REGISTER_U1	-26+3
#define	VX_REGISTER_V1	-26+4
#define	VX_REGISTER_C1	-26+5
#define	VX_REGISTER_Y2	-20+0
#define	VX_REGISTER_X2	-20+1
#define	VX_REGISTER_U2	-20+3
#define	VX_REGISTER_V2	-20+4
#define	VX_REGISTER_C2	-20+5

#define	VX_FDVDY	-12
#define	VX_FDUDY	-10
#define	VX_FDVDX	-6
#define	VX_FDUDX	-4

#define	VX_SHADER_INTERPOLATION_CODE	$E30800

	.addinstr ld deu,0 13521B52 4 NOP 0
	.addinstr ld hlu,0 23522B52 4 NOP 0
	.addinstr ld bcu,0 03520B52 4 NOP 0

	.fill	32
VX_PIXEL_SHADER_DATA:
	.fill	3072

VX_SHADER_INTERPOLATION_COPY:

.relocate VX_SHADER_INTERPOLATION_CODE

vxTexturePolygon:
	sub	a, 2
	ld	b, a
	ld	hl, (iy+0)
vxTextureCyclicLoop:
	push	bc
	ld	de, (iy+3)
	ld	bc, (iy+6)
	push	hl
	push	iy
	push	hl
	push	bc
	push	de
	call	vxNClip
	pop	de
	pop	bc
	pop	hl
	call	nc,vxTextureTriangleNoClip
	pop	iy
	lea	iy, iy+3
	pop	hl
	pop	bc
	dec	b
	jp	nz, vxTextureCyclicLoop
	ret
vxTextureTriangle:
	ld	a, (bc)
	or	(hl)
	ex	de, hl
	or	(hl)
	ld	iy, vxTexturePolygon	; load up correct subcall routine
	jp	nz, vxClipTriangle
vxTextureTriangleNoClip:
	inc	hl \ inc de \ inc bc
	ld	a, (de)
	sub	a, (hl)
	jr	c, vxTextureSwap0
	ex	de, hl
vxTextureSwap0:
	ld	a, (bc)
	sub	a, (hl)
	jr	nc, vxTextureSwap1
	push	hl
	or	a, a
	sbc	hl, hl
	add	hl, bc
	pop	bc
vxTextureSwap1:
	ld	a, (de)
	sub	a, (hl)
	jr	nc, vxTextureSwap2
	ex	de, hl
vxTextureSwap2:
	ld	a, (bc)	; is this necessary with bfc ? Nope
	sub	(hl)		; well to be safe, keep it
	ret	z		;
	ld	iy, VX_PIXEL_SHADER_DATA	; load up shader data register
; copy u&v to constant area
	push	bc
	push	de
	lea	de, iy-32
	ld	bc, 6		; 1+3+2
	ldir
	pop	hl
	ld	c, 6
	ldir
	pop	hl
	ld	c, 6
	ldir
; do e0-1
vxRegister01Interpolation:
	ld	a, (iy+VX_REGISTER_Y1)
	ld	c, (iy+VX_REGISTER_Y0)
	sub	a, c
	ld	de, (iy+VX_REGISTER_X0)
	ld	deu,0
	ld	b, 160
	mlt	bc
	ld	hl, (vxFramebuffer)
	add	hl, bc
	add	hl, bc
	add	hl, de
	push	hl				; for later, edge 0-2
	ld	bc, $FFFFFF
	jr	z, vxRegister01End
	neg
	ld	c, a
	push	de

	ex	de, hl
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ex	de, hl
	ld	ix, vxPixelShaderLengthLUT/2
	add	ix, de
	pop	de
	ld	hl, (iy+VX_REGISTER_X1)		; load x1
	ld	hlu, 0
	ld	a, $2B		; dec ix
	or	a, a
	sbc	hl, de		; hl = x1-x0
	jr	nc, vxRegister01Direction
	xor	a, $08		; inc ix	(inverted due to <0 working function)
	add	hl, de		;
	ex	de, hl		;
	sbc	hl, de		; hl = -x1+x0
vxRegister01Direction:
	ex	de, hl		; de = abs(x1-x0)
	ld	(vxRegister01Increment), a
vxRegister01ErrorAdvance:
; bc = y-size, ix = adress
; de = error
	ld	(vxRegister01SP), sp
	ld	sp, -320
	ld	a, c
	scf
	sbc	hl, hl
	ld	l, a
	sbc	hl, de
	sra	h
	rr	l
	neg
vxRegister01Loop:
	add	hl, de
	jr	nc, vxRegister01Next
vxRegister01Restore:
	.db	$DD
vxRegister01Increment=$
	nop
	add	hl, bc
	jr	c, vxRegister01Restore
vxRegister01Next:
	ld	(iy+VX_REGISTER1), ix		; this is framebuffer adress
	add	ix, sp
	lea	iy, iy+VX_REGISTER_SIZE
	dec	a
	jr	nz, vxRegister01Loop
vxRegister01SP=$+1
	ld	sp, $000000
vxRegister01End:

	ld	hl, VX_PIXEL_SHADER_DATA-26
	ld	de, VX_PIXEL_SHADER_DATA-20

vxRegister11Interpolation:
		ld	bc, $FFFFFF
	; take point0 (hl) and point1 (de), point0 is the lowest point
		ld	a, (de)
		ld	c, (hl)
		sub	a, c
		jr	z, vxRegister11End
		neg
		inc	hl
		push	de
		ld	de, (hl)
		ld	deu, 0
		push	de
		ld	l, c
		ld	c, a
		ld	h, 160
		mlt	hl
		add	hl, hl
		add	hl, de
		ld	de, (vxFramebuffer)
		add	hl, de
		ex	de, hl
		or	a, a
		sbc	hl, hl
		sbc	hl, de
		ex	de, hl
		ld	ix, vxPixelShaderLengthLUT/2
		add	ix, de
		pop	de
		pop	hl
		inc	hl			; fetch x coordinate
		ld	hl, (hl)		; load x1
		ld	hlu, 0
		ld	a, $2B		; dec ix
		or	a, a
		sbc	hl, de		; hl = x1-x0
		jr	nc, vxRegister11Direction
		xor	a, $08		; inc ix	(inverted due to <0 working function)
		add	hl, de		;
		ex	de, hl		;
		sbc	hl, de		; hl = -x1+x0
vxRegister11Direction:
		ex	de, hl		; de = abs(x1-x0)
		ld	(vxRegister11Increment), a
vxRegister11ErrorAdvance:
	; bc = y-size, ix = adress
	; de = error
		ld	(vxRegister11SP), sp
		ld	sp, -320
		ld	a, c
		scf
		sbc	hl, hl
		ld	l, a
		sbc	hl, de
		sra	h
		rr	l
		neg
vxRegister11Loop:
		add	hl, de
		jr	nc, vxRegister11Next
vxRegister11Restore:
		.db	$DD
vxRegister11Increment=$
		nop
		add	hl, bc
		jr	c, vxRegister11Restore
vxRegister11Next:
		ld	(iy+VX_REGISTER1), ix		; this is framebuffer adress
		add	ix, sp
		lea	iy, iy+VX_REGISTER_SIZE
		dec	a
		jr	nz, vxRegister11Loop
vxRegister11SP=$+1
		ld	sp, $000000
vxRegister11End:

	ld	iy, VX_PIXEL_SHADER_DATA	; load up shader data register
	ld	bc, $FFFFFF	; not necessarily here if exit with a bc < 0 previously, may be removed (end micro-opt)
vxRegister0Interpolation:
; take point0 (hl) and point1 (de), point0 is the lowest point
	ld	a, (iy+VX_REGISTER_Y2)
	ld	c, (iy+VX_REGISTER_Y0)
	sub	a, c
	neg
	ld	de, (iy+VX_REGISTER_X0)
	ld	deu, 0
	ld	c, a
	pop	ix

	ld	hl, (iy+VX_REGISTER_X2)		; load x1
	ld	hlu, 0
	push	hl
	ld	a, $23		; inc ix
	or	a, a
	sbc	hl, de		; hl = x1-x0
	jr	nc, vxRegister0Direction
	or	a, $08		; dec ix
	add	hl, de		;
	ex	de, hl		;
	sbc	hl, de		; hl = -x1+x0
vxRegister0Direction:
	ex	de, hl		; de = abs(x1-x0)
	ld	(vxRegister0Increment), a
vxRegister0ErrorAdvance:
; bc = y-size, ix = adress
; de= error
	ld	(vxRegister0SP), sp
	ld	sp, 320
	ld	a, c
	scf
	sbc	hl, hl
	ld	l, a
	sbc	hl, de
	sra	h
	rr	l
	neg
vxRegister0Loop:
	add	hl, de
	jr	nc, vxRegister0Next
vxRegister0Restore:
	.db	$DD
vxRegister0Increment=$
	nop
	add	hl, bc
	jr	c, vxRegister0Restore
vxRegister0Next:
	ld	(iy+VX_REGISTER0), ix		; this is framebuffer adress
	add	ix, sp
	lea	iy, iy+VX_REGISTER_SIZE
	dec	a
	jr	nz, vxRegister0Loop
; magic end bytes - write x2 ?
vxRegister0SP=$+1
	ld	sp, $000000
	pop	bc

	ld	(iy+VX_REGISTER0), bc
	ld	hl, vxPixelShaderExitLUT/2
	sbc hl,bc
	ld	(iy+VX_REGISTER1), hl
vxRegister0End:

; compute dudy
; compute dudx
; compute dvdy
; compute dvdx
; offset and compute register2&3
vxRegisterDerivative:
	ld	iy, VX_PIXEL_SHADER_DATA
	lea hl, iy+VX_REGISTER_Y0
	lea de, iy+VX_REGISTER_Y1
	lea bc, iy+VX_REGISTER_Y2

; compute dxdv,dydv and dxdu,dydu
; (hl), (de), (bc) = point0, 1,2
	ld	a, (de)
	sub	a, (hl)
	ld	(vxRegisterDerivativeDY0), a
	ld	(vxRegisterDerivativeDY1), a
	ld	(vxRegisterDerivativeDY2), a

	ld	a, (bc)
	sub	(hl)
	push	af
	sbc	hl, hl
	ld	l, a
	add	hl, hl
	ld	a, (bc)
	ld	bc, VX_INVERSE_TABLE
	add	hl, bc
	ld	hl, (hl)
	inc.s	hl	; essential, table have (value-1)
; hl = 65536/(y2-y0)
; FIXME : SAVE HL HERE FOR LATER
	push	hl
	ex	de, hl
	ld	d, (hl)	; substracted by y0 else it isn't correct
	sub	a, d
	ld	a, d
vxRegisterDerivativeDY0=$+1
	ld	d, $00
	ld	e, 12
	mlt	de
	add	iy, de	; doesn't modify z
; (iy) register0 hold y*320+x+framebuffer (or x2), register2 and 3 hold value u and v
; I have x1 ready too. If z flag set, y1=y2
	inc	hl
	ld hl,(hl)
	ld hlu, 0
	jr z, vxRegisterDerivativeNull
	ld e, a
	ld d, 160
	mlt	de
	add hl, de
	add	hl, de
	ld	de, (vxFramebuffer)
	add	hl, de
vxRegisterDerivativeNull:
	ld	de, (iy+VX_REGISTER0)
	ld	a, $13
	or	a, a
	sbc	hl, de		; x1-rx
; I have here interpolated dx=x1-rx value, sign is correct
; if dx < 0, make abs() and change to dec de mode (rx is at right, x1 is at left) ;; ISSUE 1 : need to correct sign based on sign of X ?
	jp	p, vxRegisterDerivativeAbs
	ex	de, hl
	or	a, $08
	sbc	hl, hl
	sbc hl, de
vxRegisterDerivativeAbs:
; write inc/dec
	ld	iy, VX_PIXEL_SHADER_DATA
	ld	(VX_PIXEL_SHADER_SUBSIZE-1+VX_PIXEL_SHADER_CODE), a
	ld	(VX_PIXEL_SHADER_SUBSIZE*2-1+VX_PIXEL_SHADER_CODE), a
	add	hl, hl
	add	hl, bc		; bc =VX_INVERE_TABLE
	ld	hl, (hl)
	inc.s	hl	; essential, table have (value-1)
; FIXME SAVE HL AND RESTORE PREVIOUS HL
	ex	(sp), hl
	ex	de, hl
; de = ratio
	ld	a, (iy+VX_REGISTER_V2)
	sub	(iy+VX_REGISTER_V0)
	ld	h, d
	ld	l, a
	mlt	hl
	jr	nc, $+5
	or	a, a
	sbc	hl, de
	ld	b, e
	ld	c, a
	mlt	bc
	ld	c, b
	ld	b, 0
	add	hl, bc
	ld	(iy+VX_FDVDY), hl
; de = du/dy
; now do hl*(y1-y0)/256
; hl is fixed point 8.8 signed, a is unsigned.
	ex	de, hl
	ex	(sp), hl
	ex	de, hl
	bit	7, h		;check sign of ratio
; de = new ratio
vxRegisterDerivativeDY1=$+1
	ld	a, 0
	ld	b, a
	ld	c, h
	mlt	bc
	rl	h
	ld	h, a
	jr	nc, $+5
	cpl
	adc	a, b
	ld	b, a
	mlt	hl
	ld	l, h
	ld	h, 0
	add	hl, bc
; interesting value is l
	ld	c, (iy+VX_REGISTER_V0)
	ld	b, 0
	add	hl, bc
	bit	7, h
	jr	z, $+4
	ld	l, 0
; in theory the value here is >0
	ld	a, (iy+VX_REGISTER_V1)
	sub	a, l
	ld	h, d
	ld	l, a
	mlt	hl
	jr	nc, $+5
	or	a, a
	sbc	hl, de
	ld	b, e
	ld	c, a
	mlt	bc
; divide by 256
	ld	c, b
	ld	b, 0
	add	hl, bc
	ld	(iy+VX_FDVDX), hl

	ex	de, hl
	ex	(sp), hl
	ex	de, hl
; now compute gradient for v paramater
	ld	a, (iy+VX_REGISTER_U2)
	sub	(iy+VX_REGISTER_U0)
	ld	h, d
	ld	l, a
	mlt	hl
	jr	nc, $+5
	or	a, a
	sbc	hl, de
	ld	b, e
	ld	c, a
	mlt	bc
	ld	c, b
	ld	b, 0
	add.s	hl, bc
	ld	de, (iy+VX_FDVDY)
	bit	7, d
	jr	z, $+4
	dec.s	hl
	ld	(iy+VX_FDUDY), hl
	pop	de
; hl = dv/dy
; now do hl*(y1-y0)/256
; hl is fixed point 8.8 signed, a is unsigned.
; de = new ratio
vxRegisterDerivativeDY2=$+1
	ld	a, 0

	ld	b, a
	ld	c, h
	mlt	bc
	rl	h
	ld	h, a
	jr	nc, $+5
	cpl
	adc	a, b
	ld	b, a
	mlt	hl
	ld	l, h
	ld	h, 0
	add	hl, bc
; interesting value is l
	ld	c, (iy+VX_REGISTER_U0)
	ld	b, 0
	add	hl, bc
	bit	7, h
	jr	z, $+4
	ld	l, 0
	ld	a, (iy+VX_REGISTER_U1)
	sub	a, l
	ld	h, d
	ld	l, a
	mlt	hl
	jr	nc, $+5
	or	a, a
	sbc	hl, de
	ld	b, e
	ld	c, a
	mlt	bc
; divide by 256
	ld	c, b
	ld	b, 0
	add.s	hl, bc
; sign correction for interpolation
	ld	de, (iy+VX_FDVDX)
	bit	7, d
	jr	z, $+4
	dec.s	hl
	ld	(iy+VX_FDUDX), hl
; interpolate u,v register2 and register3, and initialise drawing

; hl = u0*256+(dudy+dudx)/2, ix=v0*256+(dvdy+dvdx)/2
	ld	hl, (iy+VX_FDVDY)
	ld	de, (iy+VX_FDVDX)
	add.s	hl, de
	sra	h \ rr l
	ex	de, hl
	ld	hl, (iy+VX_FDUDY)
	ld	bc, (iy+VX_FDUDX)
	add.s	hl, bc
	sra	h \ rr  l
	ld	a, l
	ld	(vxShaderOffset+2), a
	ld	a, h

vxShaderTexturePage=$+1
	ld	hl, $D30000
	ld	l, (iy+VX_REGISTER_U0)
	add	a, l
	ld	l, a
vxShaderOffset=$+2
	ld	ix, $000000
	ld	a, (iy+VX_REGISTER_V0)
	add	a, d
	ld	ixh, a
	ld	ixl, e
; load de and bc
	ld	bc, (iy+VX_FDVDY)
	ld	de, (iy+VX_FDUDY+1)
; ready to interpolate
	pop	af
vxRegisterGradientLoop:
	ld	(iy+VX_REGISTER2), ix
	ld	(iy+VX_REGISTER3), hl
	add	ix, bc	; v interpolation on y
	adc	hl, de	; u interpolation on y
	dec	a
	jr	z, vxRegisterGradientEnd
	ld	(iy+VX_REGISTER2+VX_REGISTER_SIZE), ix
	ld	(iy+VX_REGISTER3+VX_REGISTER_SIZE), hl
	add	ix, bc	; v interpolation on y
	adc	hl, de	; u interpolation on y
	lea	iy, iy+(VX_REGISTER_SIZE*2)
	dec	a
	jr	nz, vxRegisterGradientLoop
vxRegisterGradientEnd:
; initialise drawing
	ld	ix, VX_PIXEL_SHADER_CODE
	ld	iy, VX_PIXEL_SHADER_DATA
; hl'= texture page and accumulator for dux	LOADED
; de'= low byte is dux											INIT
; sp = dux*65536+dvx												INIT
; bc'= undefined														INIT
; hl = accumulator for dux									LOADED
; de = screen adress												LOADED
; bc = djnz size														LOADED
	ld	(vxPixelShaderExit+1), sp
vxShaderUniform0=$+1
	ld	bc, VX_PIXEL_SHADER_CONSTANT
	ld	hl, (iy+VX_FDVDX)
	ld	sp, hl
	ld	de, (iy+VX_FDUDX+1)
	exx
	jp	vxShaderGeneralInterpolation
vxPixelShaderExit:
	ld	sp, $000000
	ret
vxMipmapLOD:
; THIS IS HALF BROKEN AND CANT BE USED RIGHT NOW
;    vec2  dx_vtc        = dFdx;
;    vec2  dy_vtc        = dFdy;
;    float delta_max_sqr = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
;    return 0.5 * log2(delta_max_sqr)
	ld	a, (VX_FDUDX+1) ;dudx+1
	bit	7, a \ jr z, $+4 \ neg
	ld	l, a
	ld	h, a
	mlt	hl
	ld	a, (VX_FDVDX+1) ;dvdx+1
	bit	7, a \ jr z, $+4 \ neg
	ld	d, a
	ld	e, a
	mlt	de
	add	hl, de
	push	hl
	ld	a, (VX_FDUDY+1) ;dudy+1
	bit	7, a \ jr z, $+4 \ neg
	ld	l, a
	ld	h, a
	mlt	hl
	ld	a, (VX_FDVDY+1) ;dvdy+1
	bit	7, a \ jr z, $+4 \ neg
	ld	d, a
	ld	e, a
	mlt	de
	add	hl, de
	pop	de
; max(hl,de)
	or	a, a
	sbc	hl, de
	add	hl, de
	jr	nc, $+3
	ex	de, hl
	jr	nz, $+3
	inc	hl
; compute log2
	ld	a,16
	scf
__LogLoop:
	adc.s	hl,hl
	dec	a
	jr	nc,__LogLoop
; result is between [-1;15]
; 256x256 texture have 9 mipmap levels.
	srl	a	; remap to [0-8]
; clamp the result to [0-8]
; correspondance :
; 256x256 : 0
; 128x128 : 1
;  64x 64 : 2
;  32x 32 : 3
;  16x 16 : 4
;   8x  8 : 5
;   4x  4 : 6
;   2x  2 : 7
;   1x  1 : 8
	ret
.endrelocate

#include "vxPixelShader.inc"

VX_INVERSE_TABLE:
.dw 65534	; position 0, so nothing in fact (div by 0)
.dw 65534	; corrected
.dw 32767
.dw 21844
.dw 16383
.dw 13106
.dw 10921
.dw 9361
.dw 8191
.dw 7280
.dw 6552
.dw 5956
.dw 5460
.dw 5040
.dw 4680
.dw 4368
.dw 4095
.dw 3854
.dw 3639
.dw 3448
.dw 3275
.dw 3119
.dw 2977
.dw 2848
.dw 2729
.dw 2620
.dw 2519
.dw 2426
.dw 2339
.dw 2258
.dw 2183
.dw 2113
.dw 2047
.dw 1984
.dw 1926
.dw 1871
.dw 1819
.dw 1770
.dw 1723
.dw 1679
.dw 1637
.dw 1597
.dw 1559
.dw 1523
.dw 1488
.dw 1455
.dw 1423
.dw 1393
.dw 1364
.dw 1336
.dw 1309
.dw 1284
.dw 1259
.dw 1235
.dw 1212
.dw 1190
.dw 1169
.dw 1148
.dw 1128
.dw 1109
.dw 1091
.dw 1073
.dw 1056
.dw 1039
.dw 1023
.dw 1007
.dw 991
.dw 977
.dw 962
.dw 948
.dw 935
.dw 922
.dw 909
.dw 896
.dw 884
.dw 872
.dw 861
.dw 850
.dw 839
.dw 828
.dw 818
.dw 808
.dw 798
.dw 788
.dw 779
.dw 770
.dw 761
.dw 752
.dw 743
.dw 735
.dw 727
.dw 719
.dw 711
.dw 703
.dw 696
.dw 688
.dw 681
.dw 674
.dw 667
.dw 660
.dw 654
.dw 647
.dw 641
.dw 635
.dw 629
.dw 623
.dw 617
.dw 611
.dw 605
.dw 600
.dw 594
.dw 589
.dw 584
.dw 578
.dw 573
.dw 568
.dw 563
.dw 559
.dw 554
.dw 549
.dw 545
.dw 540
.dw 536
.dw 531
.dw 527
.dw 523
.dw 519
.dw 515
.dw 511
.dw 507
.dw 503
.dw 499
.dw 495
.dw 491
.dw 488
.dw 484
.dw 480
.dw 477
.dw 473
.dw 470
.dw 467
.dw 463
.dw 460
.dw 457
.dw 454
.dw 450
.dw 447
.dw 444
.dw 441
.dw 438
.dw 435
.dw 433
.dw 430
.dw 427
.dw 424
.dw 421
.dw 419
.dw 416
.dw 413
.dw 411
.dw 408
.dw 406
.dw 403
.dw 401
.dw 398
.dw 396
.dw 393
.dw 391
.dw 389
.dw 386
.dw 384
.dw 382
.dw 380
.dw 377
.dw 375
.dw 373
.dw 371
.dw 369
.dw 367
.dw 365
.dw 363
.dw 361
.dw 359
.dw 357
.dw 355
.dw 353
.dw 351
.dw 349
.dw 347
.dw 345
.dw 343
.dw 342
.dw 340
.dw 338
.dw 336
.dw 335
.dw 333
.dw 331
.dw 329
.dw 328
.dw 326
.dw 325
.dw 323
.dw 321
.dw 320
.dw 318
.dw 317
.dw 315
.dw 314
.dw 312
.dw 311
.dw 309
.dw 308
.dw 306
.dw 305
.dw 303
.dw 302
.dw 301
.dw 299
.dw 298
.dw 296
.dw 295
.dw 294
.dw 292
.dw 291
.dw 290
.dw 288
.dw 287
.dw 286
.dw 285
.dw 283
.dw 282
.dw 281
.dw 280
.dw 279
.dw 277
.dw 276
.dw 275
.dw 274
.dw 273
.dw 272
.dw 270
.dw 269
.dw 268
.dw 267
.dw 266
.dw 265
.dw 264
.dw 263
.dw 262
.dw 261
.dw 260
.dw 259
.dw 258
.dw 257
.dw 256
.dw 255
.dw 254
.dw 253
.dw 252
.dw 251
.dw 250
.dw 249
.dw 248
.dw 247
.dw 246
.dw 245
.dw 244
.dw 243
.dw 242
.dw 241
.dw 240
.dw 239
.dw 239
.dw 238
.dw 237
.dw 236
.dw 235
.dw 234
.dw 233
.dw 233
.dw 232
.dw 231
.dw 230
.dw 229
.dw 228
.dw 228
.dw 227
.dw 226
.dw 225
.dw 224
.dw 224
.dw 223
.dw 222
.dw 221
.dw 221
.dw 220
.dw 219
.dw 218
.dw 218
.dw 217
.dw 216
.dw 216
.dw 215
.dw 214
.dw 213
.dw 213
.dw 212
.dw 211
.dw 211
.dw 210
.dw 209
.dw 209
.dw 208
.dw 207
.dw 207
.dw 206
.dw 205
.dw 205
.dw 204
