#define	VX_RLE_COMPRESSED	%01000000
#define	VX_ERROR_NOT_FOUND	$FF
#define	VX_ERROR_RAM_FULL	$FE

vxFindFile:
; load a file from an appv
; hl : file name
; hl = file adress
; if error : c set, a = error code
	call	_mov9toOP1
	call	_ChkFindSym
	ret	c
	call	_ChkInRam
	ex de,hl
	jr	z, vxFileUnarchived
; 9 bytes - name size (1b), name string, appv size (2b)
	ld	de, 9
	add	hl, de
	ld	e, (hl)
	add	hl, de
	inc	hl
vxFileUnarchived:
	inc	hl
	inc	hl
	ret
#comment
vxAllocateMemory:
; error = c
	push	bc
	ld	ix, vxTempMemoryBlock
	ld	hl, (ix+3)
	inc	hl
	ld	(ix+3), hl
	lea	hl, ix-1
	call  _mov9toOP1
	pop	hl
	ld	a, 16h
	call	_CreateVar
	inc	de
	inc	de
	ex	de, hl
	ret
vxTempMemoryBlock:
.db	"VMB000",0
vxCopyImage:
; hl = src ; de = dest
	ld	a, (hl)
; a = src format
	inc	hl
	ld	bc, (hl)
	dec	hl
;	mlt	bc
	ld	bc, 240*320
	push	bc
	ld	bc, 3
	ldir
	pop	bc
#endcomment

vxCopyImage:
; hl : src
; de : dest
; copy an framebuffer type image, compressed or not
; 1 byte - type, 3 bytes - size
	ld	bc, (hl)
	inc	hl \ inc hl \ inc hl
	ld	a, (hl)
	inc	hl
	tst	a, VX_RLE_COMPRESSED
	jr	nz, vxUncompressRLE
vxCopyData:
	ldir
	ret
vxUncompressRLE:
	push	de
	ex	de, hl
	add	hl, bc
	ld	(VX_MAX_RLE), hl
	ex	de, hl
	pop	de
vxRLELoop:
VX_MAX_RLE=$+1
	ld	bc, $0
	ex	de, hl
	or	a, a
	sbc	hl, bc
	ret	nc
	add	hl, bc
	ex	de, hl
	ld	bc, 0
	ld	a, (hl)
	and	$7F
	inc	a
	ld	c, a
	ld	a, (hl)
	and	$80
	jr	z, vxRLECopyRow
vxRLECopyToken:
	inc	hl
	push	hl
	ldi
	jp	po, 	vxRLECopyEnd
	scf
	sbc	hl, hl
	add	hl, de
	ldir
vxRLECopyEnd:
	pop	hl
	inc	hl
	jp	vxRLELoop
vxRLECopyRow:
	inc	hl
	ldir
	jp	vxRLELoop

vxCreateMemoryPool:
	di
	ld	a, $D1
	;ld	mb,a
	.db	$ED,$6D	; assembler bug
	ld.sis	sp,$987E
	call.is	vxUnlockWrite - $D10000
	ld	a,$D0
	;ld	mb,a
	.db	$ED,$6D

	ld	a, $3F
	call	vxMemorySafeErase
	ld	a, $3E
	call	vxMemorySafeErase
	ld	a, $3D
	call	vxMemorySafeErase
	ld	a, $3C
	call	vxMemorySafeErase

	ld	hl, $D00001
	ld	(hl), $A5
	dec	hl
	ld	(hl), $5A
	ld	de, $3C0000
	ld	bc, $40000

	call	__WriteFlash

	di
	ld.sis	sp,$987E
	ld	a, $D1
	;ld	mb,a
	.db	$ED,$6D	; assembler bug
	call.is	vxLockWrite - $D10000
	ld	a,$D0
	;ld	mb,a
	.db	$ED,$6D
; all RAM is free now

	ret

vxMemorySafeErase:
	ld	bc,$0000F8
	push	bc
	jp	__EraseFlashPage
vxDestroyMemoryPool:

; restore RAM state
	ld	hl, $3C0000
	ld	de, $D00000
	ld	bc, $010000
	ldir

;	ld	hl, $3D0000
;	ld	de, $D10000
;	ld	bc, $010000
;	ldir

	ld	hl, $3E0000
	ld	de, $D20000
	ld	bc, $010000
	ldir

	ld	hl, $3F0000
	ld	de, $D30000
	ld	bc, $010000
	ldir

	ret
.assume ADL=0
vxUnlockWrite:

	ld	a, $8C
	out0	($24), a
	ld	c, 4
	in0	a, (6)
	or	c
	out0	(6), a
	out0($28), c

	ret.l

vxLockWrite:
	xor	a, a
	out0	($28), a
	in0	a, (6)
	res	2, a
	out0	(6), a
	ld	a, $88
	out0	($24), a
	ret.l
.assume ADL=1

vxZX7Uncompress:
; Routine copied from the C toolchain & speed optimized
;  Input:
;   HL = compressed data pointer
;   DE = output data pointer
        ld      a, 128

dzx7t_copy_byte_loop:

        ldi                             ; copy literal byte

dzx7t_main_loop:

        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        jr      nc, dzx7t_copy_byte_loop ; next bit indicates either literal or sequence

; determine number of bits used for length (Elias gamma coding)

        push    de
        ld      de, 0
        ld      bc, 1

dzx7t_len_size_loop:

        inc     d
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        jr      nc, dzx7t_len_size_loop
        jp      dzx7t_len_value_start

; determine length

dzx7t_len_value_loop:

        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        rl      c
        rl      b
        jr      c, dzx7t_exit           ; check end marker

dzx7t_len_value_start:

        dec     d
        jr      nz, dzx7t_len_value_loop
        inc     bc                      ; adjust length

; determine offset

        ld      e, (hl)                 ; load offset flag (1 bit) + offset value (7 bits)
        inc     hl

        sla e
        inc e

        jr      nc, dzx7t_offset_end    ; if offset flag is set, load 4 extra bits
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        rl      d                       ; insert first bit into D
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        rl      d                       ; insert second bit into D
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        rl      d                       ; insert third bit into D
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        ccf
        jr      c, dzx7t_offset_end
        inc     d                       ; equivalent to adding 128 to DE

dzx7t_offset_end:

        rr      e                       ; insert inverted fourth bit into E

; copy previous sequence

        ex      (sp), hl                ; store source, restore destination
        push    hl                      ; store destination
        sbc     hl, de                  ; HL = destination - offset - 1
        pop     de                      ; DE = destination
       ldir

dzx7t_exit:

        pop     hl                      ; restore source address (compressed data)
        jr      nc, dzx7t_main_loop
	ret
