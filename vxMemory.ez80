#define	VX_ERROR_NOT_FOUND	$FF
#define	VX_ERROR_RAM_FULL	$FE

vxFindFile:
; load a file from an appv
; hl : file name
; hl = file adress
; if error : c set, a = error code
	call	_mov9toOP1
	call	_ChkFindSym
	ret	c
	call	_ChkInRam
	ex de,hl
	jr	z, vxFileUnarchived
; 9 bytes - name size (1b), name string, appv size (2b)
	ld	de, 9
	add	hl, de
	ld	e, (hl)
	add	hl, de
	inc	hl
vxFileUnarchived:
	inc	hl
	inc	hl
	ret

vxCreateMemoryPool:
	di
	ld	a, $D1
	;ld	mb,a
	.db	$ED,$6D	; assembler bug
	ld.sis	sp,$987E
	call.is	vxUnlockWrite - $D10000
	ld	a,$D0
	;ld	mb,a
	.db	$ED,$6D

	ld	a, $3F
	call	vxMemorySafeErase
	ld	a, $3E
	call	vxMemorySafeErase
	ld	a, $3D
	call	vxMemorySafeErase
	ld	a, $3C
	call	vxMemorySafeErase

	ld	hl, $D00001
	ld	(hl), $A5
	dec	hl
	ld	(hl), $5A
	ld	de, $3C0000
	ld	bc, $40000

	call	__WriteFlash

	di
	ld.sis	sp,$987E
	ld	a, $D1
	;ld	mb,a
	.db	$ED,$6D	; assembler bug
	call.is	vxLockWrite - $D10000
	ld	a,$D0
	;ld	mb,a
	.db	$ED,$6D
; all RAM is free now

	ret

vxMemorySafeErase:
	ld	bc,$0000F8
	push	bc
	jp	__EraseFlashPage
vxDestroyMemoryPool:

; restore RAM state
	ld	hl, $3C0000
	ld	de, $D00000
	ld	bc, $010000
	ldir

;	ld	hl, $3D0000
;	ld	de, $D10000
;	ld	bc, $010000
;	ldir

	ld	hl, $3E0000
	ld	de, $D20000
	ld	bc, $010000
	ldir

	ld	hl, $3F0000
	ld	de, $D30000
	ld	bc, $010000
	ldir

	ret
.assume ADL=0
vxUnlockWrite:

	ld	a, $8C
	out0	($24), a
	ld	c, 4
	in0	a, (6)
	or	c
	out0	(6), a
	out0($28), c

	ret.l

vxLockWrite:
	xor	a, a
	out0	($28), a
	in0	a, (6)
	res	2, a
	out0	(6), a
	ld	a, $88
	out0	($24), a
	ret.l
.assume ADL=1