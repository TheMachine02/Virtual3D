#include	"vx3D.inc"

.org userMem - 2
.db tExtTok, tAsm84CeCmp
.assume ADL=1

; init the virtual 3d library
	call	vxEngineInit
	ret	c		; quit if error at init

	ld	hl, VertexName
	call	vxFindFile
	ret	c
	ld	(Vertex), hl

	ld	hl, TriangleName
	call	vxFindFile
	ret	c
	ld	(Triangle), hl


	ld	hl, TextName
	call	vxFindFile
	ret	c
	ld	(Texture), hl

	ld	a, VX_ZX7_COMPRESSED
	ld	de, $D30000-2
	call	vxImageCopy

; about vertex coordinate :
; the format inputed in glib is pure integer 16 bits coordinates, ]-32768,32768[
; A 1.0 coordinate in blender is equivalent to 256 in glib

; setup global variable for rendering, euler angle and the translation of WorldMatrix

; about translation :
; translation are added post transformation. So they carry the multiplication with the matrice, which aren't divided by the fixed point value of 1.0 (the matrix equivalent or 64). To have a translation of 1.0 in worldview matrix, the translation need to be 256*64 = 16384.
; However, there is two type of matrix in glib : the model matrix, which is in MODELSPACE and the world type matrix in WORLDSPACE. Modelspace matrix have only a 16 bits translation and doesn't have the 64 factor described previously.

	ld	hl, 0
	ld	(EulerAngle), hl
	ld	hl, WorldMatrix
	call	vxMatrixLoadIdentity
	ld	hl, -384
	ld	(posY), hl

MainLoop:

	call	vxTimerStart

	call	Camera
	ret	nz

	ld	a, (vxKeyAnimation)
	inc a
	cp	19
	jr	nz, $+3
	xor	a, a
	ld	(vxKeyAnimation), a

; animate the texture
	ld	a, (texture_frame)
	inc	a
	cp	4
	jr	nz, $+3
	xor	a, a
	ld	(texture_frame), a
; texture_frame*16
	ld	l, a
	ld	h, 16
	mlt	hl
	ld	a, l
	add	a, 160+16
	ld	h, a
	ld	l, 0

	ld	de, 160*256+0
	ld	bc, 16*256+64
	
	call	vxImageSubCopy

	ld	a, VX_GEOMETRY_TI9
	ld	ix, WorldMatrix
	ld	iy, ModelMatrix
	ld	bc, VX_VERTEX_BUFFER
	ld	hl, (Vertex)
	ld	de, (Triangle)
	call	vxGeometryStream

	ld	a, VX_GEOMETRY_TI9
	ld	ix, WorldMatrix
	ld	iy, LaraMatrix
	ld	bc, VX_VERTEX_BUFFER+(1024*16)
	ld	hl, VERTEXDATA
	ld	de, TRIDATA
	call	vxGeometryStream

	ld	hl, (vxGeometrySize)
	ld	(triangle_count), hl

	call	vxCmdDepthSort

	ld	c, %00000000
	call	vxClearBuffer
	call	vxRenderStream

; timer & counter

	ld	bc, 320*8-1
	ld	de, (vxFramebuffer)
	or	a, a
	sbc	hl, hl
	add	hl, de
	inc	de
	ld	(hl), 0
	ldir

	ld	hl, 0
	ld	(TextXPos_SMC), hl
	ld	a, 0
	ld	(TextYPos_SMC), a

	call	vxTimerRead
; do (ade/256)/187
	ld	(Temp), de
	ld	(Temp+3), a
	ld	de, (Temp+1)
; divide de by 187
	ex	de, hl
	ld	bc, 187
	call	__idivs_ASM
	ld	de, 4
	push	de
	push	hl
	call	_PrintUInt
	pop	de
	pop	hl

	ld	hl, (TextXPos_SMC)
	ld	de, 8
	add	hl, de
	ld	(TextXPos_SMC), hl

triangle_count=$+1
	ld	hl, 0
	ld	de, 4
	push	de
	push	hl
	call	_PrintUInt
	pop	de
	pop	hl

	call	vxFlushLCD

	jp	 MainLoop
	ret

#include	"vxMain.ez80"
#include	"graphics_lib.asm"

posX:
	.dw	0
posY:
	.dw	0
posZ:
	.dw	0
Temp:
	.dl	0,0

VertexName:
	.db	AppVarObj, "TONY0",0
Vertex:
	.dl	0
TriangleName:
	.db	AppVarObj, "TONY1", 0
Triangle:
	.dl	0
TextName:
	.db	AppVarObj, "TONY2",0
Texture:
	.dl	0

ScaleMatrix:
	.db	77,0,0		; 44
	.db	0,102,0		; 58
	.db	0,0,64		; 37
UnitVector:
	.dl	0,16384,0
Quaternion:
	.dl	0,0,0,0
QuatMatrix:
	.dl	0,0,0,0,0,0
WorldMatrix:
	.dl	0,0,0,0,0,0
ModelMatrix:
	.db	64,0,0
	.db	0,64,0
	.db	0,0,64
	.dw	0,0,0
LaraMatrix:
	.db	64,0,0
	.db	0,64,0
	.db	0,0,64
	.dw	128,64,64
EulerAngle:
	.dl	0,0,0
texture_frame:
	.dl	0

Camera:
	ld hl,$F50000 
	ld (hl),2
	xor a,a
kwait:
	cp a,(hl)
	jr nz,kwait

	ld	de, 8
	ld	a, ($F5001E)
	bit	1, a
	jr	z, _kskip
	ld	hl, (EulerAngle)
	add	hl, de
	ld	(EulerAngle), hl
_kskip:
	ld	de, -8
	ld	a, ($F5001E)
	bit	2, a
	jr	z, _kskip2
	ld	hl, (EulerAngle)
	add	hl, de
	ld	(EulerAngle), hl
_kskip2:

	ld	hl, WorldMatrix
	call	vxMatrixLoadIdentity

	ld	hl, (EulerAngle)
	ld	iy, Quaternion
	ld	ix, UnitVector
	call	vxQuaternionRotationAxis
	ld	ix, WorldMatrix
	call	vxQuaternionGetMatrix
	ld	iy, WorldMatrix
	ld	ix, ScaleMatrix
	ld	hl, WorldMatrix
	call	vxMatrixMlt

	ld	a, ($F5001E)
	bit	0, a
	jr	z, _kskip3


	ld	de, (posX)
	ld	a, (WorldMatrix+6)
	rla
	sbc	hl, hl
	rra
	ld	l, a
	add	hl, hl
	or	a, a
	add	hl, de
	ld	de, (posY)
	ld	(posX), hl
	ld	a, (WorldMatrix+7)
	rla
	sbc	hl, hl
	rra
	ld	l, a
	add	hl, hl
	or	a, a
	add	hl, de
	ld	de, (posZ)
	ld	(posY), hl
	ld	a, (WorldMatrix+8)
	rla
	sbc	hl, hl
	rra
	ld	l, a
	add	hl, hl
	or	a, a
	add	hl, de
	ld	(posZ), hl
_kskip3:

	ld	a, ($F5001E)
	bit	3, a
	jr	z, _kskip4

	ld	de, (posX)
	ld	a, (WorldMatrix+6)
	neg
	rla
	sbc	hl, hl
	rra
	ld	l, a
	add	hl, hl
	or	a, a
	add	hl, de
	ld	de, (posY)
	ld	(posX), hl
	ld	a, (WorldMatrix+7)
	neg
	rla
	sbc	hl, hl
	rra
	ld	l, a
	add	hl, hl
	or	a, a
	add	hl, de
	ld	de, (posZ)
	ld	(posY), hl
	ld	a, (WorldMatrix+8)
	neg
	rla
	sbc	hl, hl
	rra
	ld	l, a
	add	hl, hl
	or	a, a
	add	hl, de
	ld	(posZ), hl
_kskip4:


	ld	hl, (posY)
	ld	de, 32
	ld	a, ($F50012)
	bit	0, a
	jr	z, _kskip6
	add	hl, de
_kskip6:	

	bit	4, a
	jr	z, _kskip7
	or	a, a
	sbc	hl, de
_kskip7:
	
	ld	a, l
	ld	(posY), a
	ld	a, h
	ld	(posY+1), a

	ld	ix, WorldMatrix
	ld	iy, posX
	call	vxfTransform
	ld	hl, vxPosition
	ld	de, WorldMatrix+9
	ld	bc, 9
	ldir

	ld a,($F5001C)
	bit 6,a
	ret


#include "XML.ez80"