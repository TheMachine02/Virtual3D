#define	VX_RLE_COMPRESSED	%01000000
#define	VX_ZX7_COMPRESSED	%10000000
#define	VX_UNCOMPRESSED		%00100000

vxImageSubCopy:
; hl : org, bc : rect size, de : copy
	push	bc
	ld	bc, (vxTexturePage)
	add	hl, bc
	ex	de, hl
	add	hl, bc
	ex	de, hl
	pop	bc
	ld	a, b
	ld	b, 0
; ready to copy
vxCopyLoop:
	push	bc
	push	de
	push	hl
	ldir
	pop	hl
	pop	de
	pop	bc
	inc	h
	inc	d
	dec	a
	jr	nz, vxCopyLoop
	ret
vxImageCopy:
; hl : org, de : copy, a : format
	rla
	jr	c, vxZX7Uncompress
	rla
	jr	c, vxRLEUncompress
	ld	bc, 65536
	ldir
	ret
vxRLEUncompress:
	ret
vxZX7Uncompress:
; Routine copied from the C toolchain & speed optimized
;  Input:
;   HL = compressed data pointer
;   DE = output data pointer
        ld      a, 128

dzx7t_copy_byte_loop:

        ldi                             ; copy literal byte

dzx7t_main_loop:

        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        jr      nc, dzx7t_copy_byte_loop ; next bit indicates either literal or sequence

; determine number of bits used for length (Elias gamma coding)

        push    de
        ld      de, 0
        ld      bc, 1

dzx7t_len_size_loop:

        inc     d
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        jr      nc, dzx7t_len_size_loop
        jp      dzx7t_len_value_start

; determine length

dzx7t_len_value_loop:

        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        rl      c
        rl      b
        jr      c, dzx7t_exit           ; check end marker

dzx7t_len_value_start:

        dec     d
        jr      nz, dzx7t_len_value_loop
        inc     bc                      ; adjust length

; determine offset

        ld      e, (hl)                 ; load offset flag (1 bit) + offset value (7 bits)
        inc     hl

        sla e
        inc e

        jr      nc, dzx7t_offset_end    ; if offset flag is set, load 4 extra bits
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        rl      d                       ; insert first bit into D
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        rl      d                       ; insert second bit into D
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        rl      d                       ; insert third bit into D
        add     a, a                    ; check next bit
 	jr nz,$+5 \ ld a,(hl) \ inc hl \ rla
        ccf
        jr      c, dzx7t_offset_end
        inc     d                       ; equivalent to adding 128 to DE

dzx7t_offset_end:

        rr      e                       ; insert inverted fourth bit into E

; copy previous sequence

        ex      (sp), hl                ; store source, restore destination
        push    hl                      ; store destination
        sbc     hl, de                  ; HL = destination - offset - 1
        pop     de                      ; DE = destination
       ldir

dzx7t_exit:

        pop     hl                      ; restore source address (compressed data)
        jr      nc, dzx7t_main_loop
	ret

vxMipmapLOD:
; THIS IS HALF BROKEN AND CANT BE USED RIGHT NOW
;    vec2  dx_vtc        = dFdx;
;    vec2  dy_vtc        = dFdy;
;    float delta_max_sqr = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
;    return 0.5 * log2(delta_max_sqr)
	ld	a, (VX_FDUDX+1) ;dudx+1
	bit	7, a \ jr z, $+4 \ neg
	ld	l, a
	ld	h, a
	mlt	hl
	ld	a, (VX_FDVDX+1) ;dvdx+1
	bit	7, a \ jr z, $+4 \ neg
	ld	d, a
	ld	e, a
	mlt	de
	add	hl, de
	push	hl
	ld	a, (VX_FDUDY+1) ;dudy+1
	bit	7, a \ jr z, $+4 \ neg
	ld	l, a
	ld	h, a
	mlt	hl
	ld	a, (VX_FDVDY+1) ;dvdy+1
	bit	7, a \ jr z, $+4 \ neg
	ld	d, a
	ld	e, a
	mlt	de
	add	hl, de
	pop	de
; max(hl,de)
	or	a, a
	sbc	hl, de
	add	hl, de
	jr	nc, $+3
	ex	de, hl
	jr	nz, $+3
	inc	hl
; compute log2
	ld	a,16
	scf
__LogLoop:
	adc.s	hl,hl
	dec	a
	jr	nc,__LogLoop
; result is between [-1;15]
; 256x256 texture have 9 mipmap levels.
	srl	a	; remap to [0-8]
; clamp the result to [0-8]
; correspondance :
; 256x256 : 0
; 128x128 : 1
;  64x 64 : 2
;  32x 32 : 3
;  16x 16 : 4
;   8x  8 : 5
;   4x  4 : 6
;   2x  2 : 7
;   1x  1 : 8
	ret