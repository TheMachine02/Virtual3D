vxMemoryFind:
; load a file from an appv
; hl : file name
; hl = file adress
; if error : c set, a = error code
	call	_mov9toOP1
	call	_ChkFindSym
	ret	c
	call	_ChkInRam
	ex de,hl
	jr	z, vxMemoryUnarchived
; 9 bytes - name size (1b), name string, appv size (2b)
	ld	de, 9
	add	hl, de
	ld	e, (hl)
	add	hl, de
	inc	hl
vxMemoryUnarchived:
	inc	hl
	inc	hl
	ret

vxMemoryCreateDevice:
	ld	a, $3F
	call	vxMemorySafeErase
	ld	a, $3E
	call	vxMemorySafeErase
	ld	a, $3D
	call	vxMemorySafeErase
	ld	a, $3C
	call	vxMemorySafeErase
	ld	hl, $D00001
	ld	(hl), $A5
	dec	hl
	ld	(hl), $5A
	ld	de, $3C0000
	ld	bc, $40000
	jp	__WriteFlash
vxMemorySafeErase:
	ld	bc,$0000F8
	push	bc
	jp	__EraseFlashPage

vxMemoryDestroyDevice:
; restore RAM state
	ld	hl, $3C0000
	ld	de, $D00000
	ld	bc, $01887C
	ldir
; sps, spl stack aren't copied obviously
	ld	hl, $3DA881
	ld	de, $D1A881
	ld	bc, $02577F
	ldir
	ret

.assume ADL=0
vxMemoryUnlock:
	di
	ld	a, $D1
	.db	$ED,$6D	; assembler bug
	ld.sis	sp,$987E
	call.is	vxMemoryRawUnlock-$D10000
	ld	a,$D0
	.db	$ED,$6D
	ret
vxMemoryLock:
	di
	ld	a, $D1
	.db	$ED,$6D	; assembler bug
	ld.sis	sp,$987E
	call.is	vxMemoryRawLock-$D10000
	ld	a,$D0
	.db	$ED,$6D
	ret
vxMemoryRawUnlock:
	ld	a, $8C
	out0	($24), a
	ld	c, 4
	in0	a, (6)
	or	c
	out0	(6), a
	out0($28), c
	ret.l
vxMemoryRawLock:
	xor	a, a
	out0	($28), a
	in0	a, (6)
	res	2, a
	out0	(6), a
	ld	a, $88
	out0	($24), a
	ret.l
.assume ADL=1