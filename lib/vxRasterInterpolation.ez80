#include "shader/vxPixelShader.inc"

#define	VX_REGISTER_Y0	-32+0
#define	VX_REGISTER_X0	-32+1
#define	VX_REGISTER_U0	-32+3
#define	VX_REGISTER_V0	-32+4
#define	VX_REGISTER_C0	-32+5
#define	VX_REGISTER_Y1	-26+0
#define	VX_REGISTER_X1	-26+1
#define	VX_REGISTER_U1	-26+3
#define	VX_REGISTER_V1	-26+4
#define	VX_REGISTER_C1	-26+5
#define	VX_REGISTER_Y2	-20+0
#define	VX_REGISTER_X2	-20+1
#define	VX_REGISTER_U2	-20+3
#define	VX_REGISTER_V2	-20+4
#define	VX_REGISTER_C2	-20+5

#define	VX_FDVDY	-12
#define	VX_FDUDY	-10
#define	VX_FDVDX	-6
#define	VX_FDUDX	-4

#define	VX_REGISTER_INTERPOLATION_CODE	$E30800
#define	VX_REGISTER_INTERPOLATION_SIZE	1024

	.addinstr ld deu,0 13521B52 4 NOP 0
	.addinstr ld hlu,0 23522B52 4 NOP 0
	.addinstr ld bcu,0 03520B52 4 NOP 0

VX_REGISTER_DATA:
	.fill	32, 0
VX_PIXEL_SHADER_DATA:
	.fill	2892, 0

VX_REGISTER_INTERPOLATION_COPY:

.relocate VX_REGISTER_INTERPOLATION_CODE

vxTexturePolygon:
	sub	a, 2
	ld	b, a
	ld	hl, (iy+0)
vxTextureCyclicLoop:
	push	bc
	ld	de, (iy+3)
	ld	bc, (iy+6)
	push	hl
	pea	iy+3
	push	hl
	push	bc
	push	de
	call	vxNClip
	pop	de
	pop	bc
	pop	hl
	call	nc,vxTextureTriangleNoClip
	pop	iy
	pop	hl
	pop	bc
	djnz vxTextureCyclicLoop
	ret
vxTextureTriangle:
	ld	a, (bc)
	or	(hl)
	ex	de, hl
	or	(hl)
	ld	iy, vxTexturePolygon	; load up correct subcall routine
	jp	nz, vxClipTriangle
vxTextureTriangleNoClip:
	inc	hl \ inc de \ inc bc
	ld	a, (de)
	sub	a, (hl)
	jr	c, vxTextureSwap0
	ex	de, hl
vxTextureSwap0:
	ld	a, (bc)
	sub	a, (hl)
	jr	nc, vxTextureSwap1
	push	hl
	or	a, a
	sbc	hl, hl
	add	hl, bc
	pop	bc
vxTextureSwap1:
	ld	a, (de)
	sub	a, (hl)
	jr	nc, vxTextureSwap2
	ex	de, hl
vxTextureSwap2:
	ld	a, (bc)	; is this necessary with bfc ? Nope
	sub	(hl)	; well to be safe, keep it
	ret	z	;
	ld	iy, VX_PIXEL_SHADER_DATA	; load up shader data register
; copy u&v to constant area
	push	bc
	push	de
	lea	de, iy-32
	ld	bc, 6
	ld	a, c
	ldir
	pop	hl
	ld	c, a
	ldir
	pop	hl
	ld	c, a
	ldir
; do e0-1
vxRegister01Interpolation:
	ld	a, (iy+VX_REGISTER_Y1)
	ld	e, (iy+VX_REGISTER_Y0)
	sub	a, e
	ld	hl, (iy+VX_REGISTER_X0)
	ld	d, 160
	mlt	de
	ex.s	de, hl
	add	hl, hl
	add	hl, de
	ld	bc, (vxFramebuffer)
	add	hl, bc
	push	hl		; for later, edge 0-2
	ld	bc, $FFFFFF
	jr	z, vxRegister01End
	neg
	ld	c, a
	push	de

	ex	de, hl
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ex	de, hl
	ld	ix, VX_LUT_PIXEL_LENGTH/2
	add	ix, de
	pop	de
	ld	hl, (iy+VX_REGISTER_X1)	; load x1
	ex.s	de, hl
	ld	a, $23	; dec ix
	or	a, a
	sbc	hl, de	; hl = x1-x0
	jr	nc, vxRegister01Direction
	add	hl, de	;
	ex	de, hl	;
	xor	a, $08	; inc ix	(inverted due to <0 working function)
	sbc	hl, de	; hl = -x1+x0
vxRegister01Direction:
	ex	de, hl	; de = abs(x1-x0)
	ld	(vxRegister01Increment), a
vxRegister01ErrorAdvance:
; bc = y-size, ix = adress
; de = error
	ld	(vxRegister01SP), sp
	ld	sp, -320
	ld	a, c
	scf
	sbc	hl, hl
	ld	l, a
	sbc	hl, de
	sra	h
	rr	l
	neg
vxRegister01Loop:
	add	hl, de
	jr	nc, vxRegister01Next
vxRegister01Restore:
	.db	$DD
vxRegister01Increment=$
	nop
	add	hl, bc
	jr	c, vxRegister01Restore
vxRegister01Next:
	ld	(iy+VX_REGISTER1), ix	; this is framebuffer adress
	add	ix, sp
	lea	iy, iy+VX_REGISTER_SIZE
	dec	a
	jr	nz, vxRegister01Loop
vxRegister01SP=$+1
	ld	sp, $000000
vxRegister01End:
; here bc < 0 already, only need to write c
	
	ld	ix, VX_PIXEL_SHADER_DATA

vxRegister11Interpolation:
; take point0 (hl) and point1 (de), point0 is the lowest point
	ld	a, (ix+VX_REGISTER_Y2)
	ld	l, (ix+VX_REGISTER_Y1)
	sub	a, l
	jr	z, vxRegister11End
	neg
	ld	c, a
	ld	h, 160
	mlt	hl
	add	hl, hl
	ld	de, (vxFramebuffer)
	add	hl, de
	ld	de, (ix+VX_REGISTER_X1)
	ld	deu, 0
	push	de
	add	hl, de
	ex	de, hl
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ex	de, hl
	ld	hl, (ix+VX_REGISTER_X2)	; before destroying ix, fetch x2
	ld	ix, VX_LUT_PIXEL_LENGTH/2
	add	ix, de
	pop	de
	ex.s	de, hl
	ld	a, $23	; dec ix
	or	a, a
	sbc	hl, de	; hl = x2-x1
	jr	nc, vxRegister11Direction
	add	hl, de	;
	ex	de, hl	;
	xor	a, $08	; inc ix	(inverted due to <0 working function)
	sbc	hl, de	; hl = -x2+x1
vxRegister11Direction:
	ex	de, hl	; de = abs(x2-x1)
	ld	(vxRegister11Increment), a
vxRegister11ErrorAdvance:
	; bc = y-size, ix = adress
	; de = error
	ld	(vxRegister11SP), sp
	ld	sp, -320
	ld	a, c
	scf
	sbc	hl, hl
	ld	l, a
	sbc	hl, de
	sra	h
	rr	l
	neg
vxRegister11Loop:
	add	hl, de
	jr	nc, vxRegister11Next
vxRegister11Restore:
	.db	$DD
vxRegister11Increment=$
	nop
	add	hl, bc
	jr	c, vxRegister11Restore
vxRegister11Next:
	ld	(iy+VX_REGISTER1), ix	; this is framebuffer adress
	add	ix, sp
	lea	iy, iy+VX_REGISTER_SIZE
	dec	a
	jr	nz, vxRegister11Loop
vxRegister11SP=$+1
	ld	sp, $000000
vxRegister11End:

;;	ld	bc, $FFFFFF	; not necessarily here if exit with a bc < 0 previously, may be removed (end micro-opt)
vxRegister0Interpolation:
; take point0 (hl) and point1 (de), point0 is the lowest point
	pop	ix
	ld	iy, VX_PIXEL_SHADER_DATA	; load up shader data register

	ld	a, (iy+VX_REGISTER_Y0)
	sub	a, (iy+VX_REGISTER_Y2)
	ld	c, a
	ld	hl, (iy+VX_REGISTER_X0)	; load x0
	ld	de, (iy+VX_REGISTER_X2)	; load x2
	ex.s	de, hl	; trick to clear both hlu and deu
	push	hl
	ld	a, $23	; inc ix
	or	a, a
	sbc	hl, de	; hl = x1-x0
	jr	nc, vxRegister0Direction
	add	hl, de	;
	ex	de, hl	;
	or	a, $08	; dec ix
	sbc	hl, de	; hl = -x1+x0
vxRegister0Direction:
	ex	de, hl	; de = abs(x1-x0)
	ld	(vxRegister0Increment), a
vxRegister0ErrorAdvance:
; bc = y-size, ix = adress
; de= error
	ld	(vxRegister0SP), sp
	ld	sp, 320
	ld	a, c
	scf
	sbc	hl, hl
	ld	l, a
	sbc	hl, de
	sra	h
	rr	l
	neg
vxRegister0Loop:
	add	hl, de
	jr	nc, vxRegister0Next
vxRegister0Restore:
	.db	$DD
vxRegister0Increment=$
	nop
	add	hl, bc
	jr	c, vxRegister0Restore
vxRegister0Next:
	ld	(iy+VX_REGISTER0), ix	; this is framebuffer adress
	add	ix, sp
	lea	iy, iy+VX_REGISTER_SIZE
	dec	a
	jr	nz, vxRegister0Loop
; magic end bytes - write x2 ?
vxRegister0SP=$+1
	ld	sp, $000000
	pop	bc

	ld	(iy+VX_REGISTER0), bc
	ld	hl, vxPixelShaderExitLUT/2
	sbc	hl,bc
	ld	(iy+VX_REGISTER1), hl
vxRegister0End:

; compute dudy
; compute dudx
; compute dvdy
; compute dvdx
; offset and compute register2&3
vxRegisterDerivative:
	ld	iy, VX_PIXEL_SHADER_DATA
	lea	ix, iy+0
	lea hl, iy+VX_REGISTER_Y0
	lea de, iy+VX_REGISTER_Y1
	lea bc, iy+VX_REGISTER_Y2

; compute dxdv,dydv and dxdu,dydu
; (hl), (de), (bc) = point0, 1,2
	ld	a, (de)
	sub	a, (hl)
	ld	(vxRegisterDerivativeDY0), a
	ld	(vxRegisterDerivativeDY1), a
	ld	(vxRegisterDerivativeDY2), a

	ld	a, (bc)
	sub	(hl)
	push	af
	sbc	hl, hl
	ld	l, a
	add	hl, hl
	ld	a, (bc)
	ld	bc, VX_LUT_INVERSE
	add	hl, bc
	ld	hl, (hl)
	inc.s	hl	; essential, table have (value-1)
; hl = 65536/(y2-y0)
	push	hl
	ex	de, hl
	ld	d, (hl)	; substracted by y0 else it isn't correct
	sub	a, d
	ld	a, d
vxRegisterDerivativeDY0=$+1
	ld	d, $00
	ld	e, 12
	mlt	de
	add	ix, de	; doesn't modify z, in theory reset carry
; (iy) register0 hold y*320+x+framebuffer (or x2), register2 and 3 hold value u and v
; I have x1 ready too. If z flag set, y1=y2
	inc	hl
	ld	de,(hl)
	ex.s	de, hl
	jr	z, vxRegisterDerivativeNull
	ld	d, a
	ld	e, 160
	mlt	de
	add 	hl, de
	add	hl, de
	ld	de, (vxFramebuffer)
	add	hl, de
vxRegisterDerivativeNull:
	ld	de, (ix+VX_REGISTER0)
	ld	a, $13
;;	or	a, a
	sbc	hl, de	; x1-rx
; I have here interpolated dx=x1-rx value, sign is correct
; if dx < 0, make abs() and change to dec de mode (rx is at right, x1 is at left) ;; ISSUE 1 : need to correct sign based on sign of X ?
	jr	nc, vxRegisterDerivativeAbs
	add	hl, de
	ex	de, hl
	xor	a, $08
	sbc	hl, de
vxRegisterDerivativeAbs:
; write inc/dec
	ld	(VX_PIXEL_SHADER_SUBSIZE-1+VX_PIXEL_SHADER_CODE), a
	ld	(VX_PIXEL_SHADER_SUBSIZE*2-1+VX_PIXEL_SHADER_CODE), a
	add	hl, hl
	add	hl, bc	; bc =VX_INVERE_TABLE
	ld	hl, (hl)
	inc.s	hl	; essential, table have (value-1)
	ex	(sp), hl
	ex	de, hl
; de = ratio
	ld	a, (iy+VX_REGISTER_V2)
	sub	(iy+VX_REGISTER_V0)
	ld	h, d
	ld	l, a
	mlt	hl
	jr	nc, $+5
	or	a, a
	sbc	hl, de
	ld	b, e
	ld	c, a
	mlt	bc
	ld	c, b
	ld	b, 0
	add	hl, bc
	ld	(iy+VX_FDVDY), hl
; de = du/dy
; now do hl*(y1-y0)/256
; hl is fixed point 8.8 signed, a is unsigned.
	ex	de, hl
	ex	(sp), hl
	ex	de, hl
; de = new ratio
vxRegisterDerivativeDY1=$+1
	ld	b, 0
	ld	c, h
	ld	h, b
	mlt	bc
	mlt	hl
	ld	a, (iy+VX_REGISTER_V0)
	rl	l
	adc	a, h
	add	a, c

;	ld	l, a
; in theory the value here is >0
;	ld	a, (iy+VX_REGISTER_V1)
;	sub	a, l

	sub	a, (iy+VX_REGISTER_V1)
	cpl \ inc a
	jr	nz, $+6
	sbc	hl, hl
	jr	vxDerivateZero0

	ld	h, d
	ld	l, a
	mlt	hl
	jr	c, $+4
	sbc	hl, de
	ld	b, e
	ld	c, a
	mlt	bc
; divide by 256
	ld	c, b
	ld	b, 0
	add	hl, bc
vxDerivateZero0:
	ld	(iy+VX_FDVDX), hl

	ex	de, hl
	ex	(sp), hl
	ex	de, hl
; now compute gradient for v paramater
	ld	a, (iy+VX_REGISTER_U2)
	sub	(iy+VX_REGISTER_U0)
	ld	h, d
	ld	l, a
	mlt	hl
	jr	nc, $+5
	or	a, a
	sbc	hl, de
	ld	b, e
	ld	c, a
	mlt	bc
	ld	c, b
	ld	b, 0
	add.s	hl, bc
	bit	7, (iy+VX_FDVDY+1)
	jr	z, $+4
	dec.s	hl
	ld	(iy+VX_FDUDY), hl
	pop	de
; hl = dv/dy
; now do hl*(y1-y0)/256
; hl is fixed point 8.8 signed, a is unsigned.
; de = new ratio
vxRegisterDerivativeDY2=$+1
	ld	b, 0
	ld	c, h
	ld	h, b
	mlt	bc
	mlt	hl
	rl	l
	ld	a, (iy+VX_REGISTER_U0)
	adc	a, h
	add	a, c
	sub	a, (iy+VX_REGISTER_U1)
	cpl \ inc a
	jr	nz, $+6
	sbc	hl, hl
	jr	vxDerivateZero1
	ld	h, d
	ld	l, a
	mlt	hl
	jr	c, $+4
	sbc	hl, de
	ld	b, e
	ld	c, a
	mlt	bc
; divide by 256
	ld	c, b
	ld	b, 0
	add.s	hl, bc
vxDerivateZero1:
; sign correction for interpolation
	bit	7, (iy+VX_FDVDX+1)
	jr	z, $+4
	dec.s	hl
	ld	(iy+VX_FDUDX), hl
; interpolate u,v register2 and register3, and initialise drawing

; hl = u0*256+(dudy+dudx)/2, ix=v0*256+(dvdy+dvdx)/2
	ld	hl, (iy+VX_FDVDY)
	ld	de, (iy+VX_FDVDX)
	add.s	hl, de
	sra	h \ rr l
	ex	de, hl
	ld	hl, (iy+VX_FDUDY)
	ld	bc, (iy+VX_FDUDX)
	add.s	hl, bc
	sra	h \ rr  l
	ld	a, l
	ld	(vxShaderOffset+2), a
	ld	a, h

vxShaderUniform1=$+1
	ld	hl, $D30000
	ld	l, (iy+VX_REGISTER_U0)
	add	a, l
	ld	l, a
vxShaderOffset=$+2
	ld	ix, $000000
	ld	a, (iy+VX_REGISTER_V0)
	add	a, d
	ld	ixh, a
	ld	ixl, e
; load de and bc
	ld	bc, (iy+VX_FDVDY)
	ld	de, (iy+VX_FDUDY+1)
; ready to interpolate
	pop	af
vxRegisterGradientLoop:
	ld	(iy+VX_REGISTER2), ix
	ld	(iy+VX_REGISTER3), hl
	add	ix, bc	; v interpolation on y
	adc	hl, de	; u interpolation on y
	dec	a
	jr	z, vxRegisterGradientEnd
	ld	(iy+VX_REGISTER2+VX_REGISTER_SIZE), ix
	ld	(iy+VX_REGISTER3+VX_REGISTER_SIZE), hl
	add	ix, bc	; v interpolation on y
	adc	hl, de	; u interpolation on y
	lea	iy, iy+(VX_REGISTER_SIZE*2)
	dec	a
	jr	nz, vxRegisterGradientLoop
vxRegisterGradientEnd:
; initialise drawing
	ld	ix, VX_PIXEL_SHADER_CODE
	ld	iy, VX_PIXEL_SHADER_DATA
; hl'= texture page and accumulator for dux	LOADED
; de'= low byte is dux						INIT
; sp = dux*65536+dvx						INIT
; bc'= undefined							INIT
; hl = accumulator for dux					LOADED
; de = screen adress						LOADED
; bc = djnz size							LOADED
	ld	(vxPixelShaderExit+1), sp
vxShaderUniform0=$+1
	ld	bc, VX_PIXEL_SHADER_CONSTANT
	ld	hl, (iy+VX_FDVDX)
	ld	sp, hl
	ld	de, (iy+VX_FDUDX+1)
	exx
	jp	vxShaderGeneralInterpolation
vxPixelShaderExit:
	ld	sp, $000000
	ret
vxTextureLOD:
;    vec2  dx_vtc        = dFdx;
;    vec2  dy_vtc        = dFdy;
;    float delta_max_sqr = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
;    return 0.5 * log2(delta_max_sqr)
; correspondance :
; 256x256 : 0
; 128x128 : 1
;  64x 64 : 2
;  32x 32 : 3
;  16x 16 : 4
;   8x  8 : 5
;   4x  4 : 6
;   2x  2 : 7
;   1x  1 : 8
	ret
.endrelocate