#define	VX_MATRIX_SIZE	18
#define	VX_VECTOR16X	0
#define	VX_VECTOR16Y	2
#define	VX_VECTOR16Z	4
#define	VX_VECTOR8X	0
#define	VX_VECTOR8Y	1
#define	VX_VECTOR8Z	2

vxIdentityMatrix:
.db	64,0,0
.db	0,64,0
.db	0,0,64
.dl	0,0,0
vxProjectionMatrix:
.db	77,0,0
.db	0,102,0
.db	0,0,64
.dl	0,0,0
vxTmpVector:
.dw	0,0,0
.db	0	; pad
vxLookAtMatrix:
.db	0,0,0
.db	0,0,0
.db	0,0,0
.dl	0,0,0

vxMatrixLoadIdentity:
; input : hl matrix
	ex	de, hl
	ld	hl, vxIdentityMatrix
	ld	bc, VX_MATRIX_SIZE
	ldir
	ex	de, hl
	ld	bc, -VX_MATRIX_SIZE
	add	hl, bc
	ret
vxMatrixRotationX:
#comment
	ld	a, l
	ld	hl, ISIN_TABLE
	ld	l, a
	ld	a, (hl)
	ld	(ix+7), a
	neg
	ld	(ix+5), a
	ld	a, l
	add	a, 64
	ld	l, a
	ld	c, (hl)
	ld	(ix+4), c
	ld	(ix+8), c
	ld	a, 64
	ld	(ix+0), a
	xor	a, a
	ld	(ix+1), a
	ld	(ix+2), a
	ld	(ix+3), a
	ld	(ix+6), a
#endcomment
	push	hl
	call	vxSin
	ld	a, h
	ld	(ix+7), a
	neg
	ld	(ix+5), a
	pop	hl
	call	vxCos
	ld	(ix+4), h
	ld	(ix+8), h
	ld	a, 64
	ld	(ix+0), a
	xor	a, a
	ld	(ix+1), a
	ld	(ix+2), a
	ld	(ix+3), a
	ld	(ix+6), a
	ret
vxMatrixRotationZ:
#comment
	ld	a, l
	ld	hl, ISIN_TABLE
	ld	l, a
	ld	a, (hl)
	ld	(ix+3), a
	neg
	ld	(ix+1), a
	ld	a, l
	add	a, 64
	ld	l, a
	ld	c, (hl)
	ld	(ix+0), c
	ld	(ix+4), c
	ld	a, 64
	ld	(ix+8), a
	xor	a, a
	ld	(ix+2), a
	ld	(ix+6), a
	ld	(ix+7), a
	ld	(ix+5), a
#endcomment
	push	hl
	call	vxSin
	ld	a, h
	ld	(ix+3), a
	neg
	ld	(ix+1), a
	pop	hl
	call	vxCos
	ld	(ix+0), h
	ld	(ix+4), h
	ld	a, 64
	ld	(ix+8), a
	xor	a, a
	ld	(ix+2), a
	ld	(ix+6), a
	ld	(ix+7), a
	ld	(ix+5), a
	ret
vxMatrixRotationY:
	push	hl
	call	vxSin
	ld	a, h
	ld	(ix+2), a
	neg
	ld	(ix+6), a
	pop	hl
	call	vxCos
	ld	(ix+0), h
	ld	(ix+8), h
	ld	a, 64
	ld	(ix+4), a
	xor	a, a
	ld	(ix+1), a
	ld	(ix+3), a
	ld	(ix+5), a
	ld	(ix+7), a
	ret
vxMatrixMlt:
; (hl) = (iy) * (ix)
; 116 bytes, ~3800 TStates
	ex	de, hl
	ld	bc, 768
vxMatrixColLoop:
	push	bc
	ld	b, 3
vxMatrixRowLoop:
	push	bc
	ld	h, (ix+0)
	ld	l, (iy+0)
	xor	a, a
	bit	7, h \ jr z, $+3 \ sub a, l
	bit	7, l \ jr z, $+3 \ sub a, h
	mlt	hl
	ld	b, (ix+1)
	ld	c, (iy+3)
	bit	7, b \ jr z, $+3 \ sub a, c
	bit	7, c \ jr z, $+3 \ sub a, b
	mlt	bc
	add	hl, bc
	ld	b, (ix+2)
	ld	c, (iy+6)
	bit	7, b \ jr z, $+3 \ sub a, c
	bit	7, c \ jr z, $+3 \ sub a, b
	mlt	bc
	add	hl, bc
	ld	b, a
	xor	a, a
	ld	c, a
	add	hl, bc
	add	hl, hl
	add	hl, hl
	ld	a, h
	ld	(de), a
	inc	de
	inc	iy
	pop	bc
	djnz	vxMatrixRowLoop
	lea	ix, ix+3
	lea	iy, iy-3
	pop	bc
	djnz	vxMatrixColLoop
	lea	ix, ix-9
	ex	de, hl
	ld	bc, -9
	add	hl, bc
	ret
vxMatrixTransform:
; (hl) = (iy)*(ix) with translation
; iy is a animation matrix, ix is a world matrix, hl is world matrix
	push	hl
	lea	iy, iy+9	; load up the translation of matrix 0
	call	vxfTransform
	lea	iy, iy-9
	pop	hl
	call	vxMatrixMlt
; copy translation data to result (hl)
	ld	bc, 9
	add	hl, bc
	ld	de, vxPosition
	ex	de, hl
	ldir
	ld	bc, -VX_MATRIX_SIZE
	ex	de, hl
	add	hl, bc
	ret
vxMatrixTranspose:
; 192 TStates + translation
	ld	c, (ix+3)
	ld	a, (ix+1)
	ld	(ix+3), a
	ld	(ix+1), c
	ld	c, (ix+6)
	ld	a, (ix+2)
	ld	(ix+6), a
	ld	(ix+2), c
	ld	c, (ix+7)
	ld	a, (ix+5)
	ld	(ix+7), a
	ld	(ix+5), c	
	ld	de, (ix+9)
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ix+9), hl
	ld	de, (ix+12)
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ix+12), hl
	ld	de, (ix+15)
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ix+15), hl
	ret
vxMatrixLightning:
	ex	de, hl
	ld	b, 3
vxMatrixLightLoop:
	push	bc
	push	de
	call	vxDotProduct
	pop	de
	add	hl, hl
	add	hl, hl
	ld	a, h
	ld	(de), a
	inc	de
	lea	ix, ix+3
	pop	bc
	djnz	vxMatrixLightLoop
	lea	ix, ix-9
	push	de
	ld	hl, (iy+VX_LIGHT_POSITION)
	ld	de, (iy+VX_LIGHT_POSITION+3)
	or	a, a
	sbc	hl, de
	pop	hl
	jr	z, vxMatrixLightEarlyOut
	dec	hl \ dec hl \ dec hl
	push	hl
; transform lightning position
	call	vxfTransform
; fetch value and divide them
; value should be copied to (hl)	
	pop	hl
	ld	bc, VX_LIGHT_POSITION+3
	add	hl, bc
	ex	de, hl
; de = adress of position.
	ld	hl, (vxPosition+6)
	add	hl, hl
	add	hl, hl
; copy hlu, h to (de)
	ex	de, hl
	ld	(hl), de
	dec	hl
	dec	hl	
	ex	de, hl
	ld	hl, (vxPosition+3)
	add	hl, hl
	add	hl, hl
	ex	de, hl
	ld	(hl), de
	dec	hl
	dec	hl
	ex	de, hl
	ld	hl, (vxPosition)
	add	hl, hl
	add	hl, hl
	ex	de, hl
	ld	(hl), de
; AMBIANT_VALUE was writed with bad value.
vxMatrixLightEarlyOut:
	inc	hl
	ld	a, (iy+VX_LIGHT_POW)
	ld	(hl), a
	dec	hl
	ld	a, (iy+VX_LIGHT_AMBIANT)
	ld	(hl), a
	dec	hl \ dec hl \ dec hl
	ret
vxfTransform:
; input : iy vector, ix matrix
; [ix+0]*[iy]+[ix+1]*[iy+2]+[ix+2]*[iy+4]+[ix+9]=x
; [ix+3]*[iy]+[ix+4]*[iy+2]+{ix+5]*[iy+4]+[ix+12]=y
; [ix+6]*[iy]+[ix+7]*[iy+2]+[ix+8]*[iy+4]+[ix+15]=z
; From 1566+x? TStates to 1654 TStates, 333 bytes
; X coordinate
; you know, I am really madd ! *coder stare at you*
	ld	bc, (iy+0)
	ld	hl, (ix+9)
	ld	a, (ix+0)
	madd
	ld	a, (ix+1)
	ld	bc, (iy+2)
	madd
	ld	a, (ix+2)
	ld	bc, (iy+4)
	madd.f
	ld	(vxPosition), hl
; Y coordinate
	ld	hl, (ix+12)
	ld	a, (ix+5)
	madd
	ld	a, (ix+4)
	ld	bc, (iy+2)
	madd
	ld	a, (ix+3)
	ld	bc, (iy+0)
	madd.f
	ld	(vxPosition+3), hl
; Z coordinate
	ld	hl, (ix+15)
	ld	a, (ix+6)
	madd
	ld	a, (ix+7)
	ld	bc, (iy+2)
	madd
	ld	a, (ix+8)
	ld	bc, (iy+4)
	madd
	ld	(vxPosition+6), hl
	ret
vxMatrixLookAt:
; zaxis = normal(At - Eye)
; xaxis = normal(cross(Up, zaxis))
; yaxis = cross(zaxis, xaxis)
; xaxis.x           xaxis.y           xaxis.z          0
; yaxis.x           yaxis.y           yaxis.z          0
; zaxis.x           zaxis.y           zaxis.z          0
;-dot(xaxis, eye)  -dot(yaxis, eye)  -dot(zaxis, eye)  l
; ix is eye, iy is At, bc is Up
	ld	de, (ix+VX_VECTOR16X)
	ld	hl, (iy+VX_VECTOR16X)
	or	a, a
	sbc	hl, de
	ld	(vxTmpVector+VX_VECTOR16X), hl

	ld	de, (ix+VX_VECTOR16Y)
	ld	hl, (iy+VX_VECTOR16Y)
	or	a, a
	sbc	hl, de
	ld	(vxTmpVector+VX_VECTOR16Y), hl

	ld	de, (ix+VX_VECTOR16Z)
	ld	hl, (iy+VX_VECTOR16Z)
	or	a, a
	sbc	hl, de
	ld	(vxTmpVector+VX_VECTOR16Z), hl

	ld	iy, vxTmpVector+VX_VECTOR16X
	ld	hl, vxLookAtMatrix+VX_MATRIX_C6
	call	vxNormalize

	push	ix
	push	bc
	pop	ix
	ld	iy, vxLookAtMatrix+VX_MATRIX_C6
	ld	hl, vxLookAtMatrix+VX_MATRIX_C0
	call	vxCrossProduct

	ld	ix, vxLookAtMatrix+VX_MATRIX_C6
	ld	iy, vxLookAtMatrix+VX_MATRIX_C0
	ld	hl, vxLookAtMatrix+VX_MATRIX_C3
	call	vxCrossProduct
	pop	iy
	ld	ix, vxLookAtMatrix
	call	vxfTransform
; here we copy negated value to translation part of the matrix
	ld	de, (vxPosition+VX_VECTOR16X)
	or	a, a \ sbc hl,hl \ sbc hl, de
	ld	(ix+VX_MATRIX_TX), hl
	ld	de, (vxPosition+VX_VECTOR16Y)
	or	a, a \ sbc hl,hl \ sbc hl, de
	ld	(ix+VX_MATRIX_TY), hl
	ld	de, (vxPosition+VX_VECTOR16Z)
	or	a, a \ sbc hl,hl \ sbc hl, de
	ld	(ix+VX_MATRIX_TZ), hl
	ret